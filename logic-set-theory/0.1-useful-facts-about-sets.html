<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sets – Practice Page</title>

  <!-- Basic layout styles -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }

    header {
      background: #222;
      color: #fff;
      padding: 1rem 1.5rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.6rem;
    }

    main {
      max-width: 900px;
      margin: 1.5rem auto 3rem;
      padding: 0 1rem 2rem;
      background: #fff;
      box-shadow: 0 0.5rem 1rem rgba(0,0,0,0.08);
      border-radius: 8px;
    }

    section {
      margin-bottom: 2rem;
    }

    h2 {
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    .pdf-wrapper {
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 1.5rem;
    }

    .note {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 0.8rem;
    }

    .latex-input {
      width: 100%;
      min-height: 70px;
      padding: 0.5rem;
      font-family: "Fira Code", "JetBrains Mono", Menlo, Monaco,
                   Consolas, "Courier New", monospace;
      font-size: 0.95rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      resize: vertical;
      margin-bottom: 0.5rem;
    }

    .rendered-output {
      min-height: 2rem;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px dashed #ccc;
      background: #fafafa;
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .rendered-output mjx-container,
    #note-render mjx-container {
      display: inline-block;
      margin-left: auto;
      margin-right: auto;
    }

    .controls {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-bottom: 0.3rem;
    }

    .copy-btn {
      padding: 0.3rem 0.7rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #333;
      color: #fff;
      font-size: 0.9rem;
    }

    .copy-btn:active {
      transform: scale(0.97);
    }

    .copy-btn.copied::after {
      content: " ✓";
    }

    /* Note board styles */
    .note-board {
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 0.75rem;
      background: #fafafa;
    }

    .note-board h3 {
      margin-top: 0;
      margin-bottom: 0.4rem;
      font-size: 1.1rem;
    }

    .note-section {
      margin-bottom: 1rem;
    }

    .canvas-wrapper {
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      background: #fff;
    }

    #note-canvas {
      display: block;
      width: 100%;
      height: 300px;
      touch-action: none; /* for better touch drawing */
    }

    #clear-canvas {
      margin-top: 0.4rem;
    }

    /* Center MathJax output */
    .rendered-output,
    #note-render {
      text-align: center;
    }

    /* Level links */
    .level-links {
      list-style: none;
      padding-left: 0;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 0.75rem;
      margin-top: 0.75rem;
    }

    .level-links li a {
      display: block;
      text-align: center;
      padding: 0.6rem 0.8rem;
      border-radius: 6px;
      text-decoration: none;
      background: #f0f0f0;
      color: #222;
      font-weight: 500;
      border: 1px solid #ddd;
      transition: background 0.15s ease, transform 0.1s ease,
                  box-shadow 0.15s ease;
    }

    .level-links li a:hover {
      background: #e4e4ff;
      box-shadow: 0 0.2rem 0.4rem rgba(0,0,0,0.08);
      transform: translateY(-1px);
    }

    .level-links li a:active {
      transform: translateY(0);
      box-shadow: none;
    }
  </style>

  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        // include amsmath so align / align* / aligned etc. work
        packages: { "[+]": ["ams"] },
        inlineMath: [["\\(","\\)"], ["$","$"]],
        displayMath: [["\\[","\\]"], ["$$","$$"]]
      },
      svg: { fontCache: "global" }
    };
  </script>

  <script id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
          async></script>
</head>
<body>
  <header>
    <h1>Sets – Beamer Slides & Problem Set</h1>
  </header>

  <main>
    <!-- PDF viewer -->
    <section>
      <h2>Slides</h2>
      <p class="note">
        Replace <code>logic0-1.pdf</code> with the name of your Beamer PDF
        file (keep it in the same folder as this HTML file).
      </p>
      <div class="pdf-wrapper">
        <!-- Adjust src to your actual PDF filename -->
        <embed src="0logic.pdf"
               type="application/pdf"
               width="100%"
               height="600px" />
      </div>
    </section>

    <!-- NOTE-TAKING BOARD -->
    <section>
      <div class="note-board">
        <h3>Note-taking Board</h3>

        <!-- LaTeX note area -->
        <div class="note-section">
          <div class="note">
            Type LaTeX notes here. The preview updates automatically.
            Click in this box, then use the backslash shortcut to open the symbol popup.
          </div>
          <textarea id="note-latex"
                    class="latex-input"
                    placeholder="e.g. A \\setminus B = \\{x \\in A : x \\notin B\\}"></textarea>
          <div id="note-render" class="rendered-output"></div>
          <div class="controls">
            <button id="copy-notes" class="copy-btn">
              Copy notes (LaTeX)
            </button>
          </div>
        </div>

        <!-- Drawing pad -->
        <div class="note-section">
          <div class="note">
            Draw/write here (mouse or touch). Use “Clear” to reset.
          </div>
          <div class="canvas-wrapper">
            <canvas id="note-canvas"></canvas>
          </div>
          <button id="clear-canvas" class="copy-btn">
            Clear drawing
          </button>
        </div>
      </div>
    </section>

    <!-- LEVEL LINKS INSTEAD OF INLINE PROBLEMS -->
    <section>
      <h2>Problem Levels</h2>
      <p class="note">
        Choose a level to open its dedicated problem page.
        All level pages are stored in the <code>logic0-1</code> folder.
      </p>
      <ul class="level-links">
        <li><a href="logic0-1/level1.html">Level 1</a></li>
        <li><a href="logic0-1/level2.html">Level 2</a></li>
        <li><a href="logic0-1/level3.html">Level 3</a></li>
        <li><a href="logic0-1/level4.html">Level 4</a></li>
        <li><a href="logic0-1/level5.html">Level 5</a></li>
        <li><a href="logic0-1/level6.html">Level 6</a></li>
        <li><a href="logic0-1/level6s.html">Level 6s</a></li>
        <li><a href="logic0-1/level7.html">Level 7</a></li>
      </ul>
    </section>
  </main>

  <!-- Root for the React symbol popup-->
  <div id="symbol-popup-root"></div>

  <!-- React + ReactDOM + Babel (for JSX popup) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- React + JSX: popup component + showSymbolPopup (same behavior as Logic Level 1) -->
  <script type="text/babel" data-presets="env,react">
    // ---------- Symbol data ----------
    window.SYMBOLS = [];
    window.RECENT_SYMBOLS = [];

    // ---------- Simple search ----------
    function searchSymbols(symbols, query) {
      const q = query.trim().toLowerCase();

      const recentList = Array.isArray(window.RECENT_SYMBOLS)
        ? window.RECENT_SYMBOLS
        : [];
      const recentSet = new Set(recentList);

      // ---------- Case 1: empty query → show recent first ----------
      if (!q) {
        const seen = new Set();
        const recent = [];
        const others = [];

        // 1) Put recents first, in recency order
        for (const latex of recentList) {
          const sym = symbols.find((s) => s.latex === latex);
          if (sym && !seen.has(sym.latex)) {
            recent.push(sym);
            seen.add(sym.latex);
          }
        }

        // 2) Then all other symbols, sorted by priority
        for (const s of symbols) {
          if (!seen.has(s.latex)) {
            others.push(s);
          }
        }

        others.sort((a, b) => (b.priority || 0) - (a.priority || 0));

        return [...recent, ...others].slice(0, 20);
      }

      // ---------- Case 2: non-empty query → scoring with recency boost ----------
      return symbols
        .map((s) => {
          const haystack = [
            s.label,
            s.latex,
            ...(s.keywords || []),
            ...(s.categories || [])
          ].join(" ").toLowerCase();

          if (!haystack.includes(q)) return null;

          let score = s.priority || 0;

          // Strong boost if this is a recent symbol
          const recIndex = recentList.indexOf(s.latex);
          if (recIndex !== -1) {
            const recencyWeight = 1.0 + (recentList.length - recIndex) * 0.05;
            score += recencyWeight;
          }

          if (s.latex.toLowerCase().startsWith("\\" + q)) score += 0.7;
          if ((s.keywords || []).some((k) => k.toLowerCase() === q)) score += 0.5;
          if (s.label.toLowerCase() === q) score += 0.4;

          const idx = haystack.indexOf(q);
          if (idx >= 0) score += Math.max(0, 0.3 - idx / 50);

          return { s, score };
        })
        .filter(Boolean)
        .sort((a, b) => b.score - a.score)
        .map((x) => x.s)
        .slice(0, 20);
    }


    const SymbolPopup = ({ x, y, initialQuery = "", onSelect, onClose }) => {
        const [query, setQuery] = React.useState("");
        const [highlightIndex, setHighlightIndex] = React.useState(0);
        const containerRef = React.useRef(null);
        const inputRef = React.useRef(null);

        const results = React.useMemo(
          () => searchSymbols(window.SYMBOLS || [], query),
          [query]
        );

        React.useEffect(() => {
          if (inputRef.current) {
            setTimeout(() => inputRef.current.focus(), 0);
          }
        }, []);


      React.useEffect(() => {
        function handleClickOutside(e) {
          if (!containerRef.current) return;
          if (!containerRef.current.contains(e.target)) {
            onClose();
          }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
      }, [onClose]);

      const handleKeyDown = (e) => {
        const count = results.length;
        if (e.key === "ArrowDown") {
          e.preventDefault();
          if (count === 0) return;
          setHighlightIndex((prev) => (prev + 1) % count);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (count === 0) return;
          setHighlightIndex((prev) => (prev - 1 + count) % count);
        } else if (e.key === "Enter") {
          e.preventDefault();
          if (count === 0) return;
          onSelect(results[highlightIndex]);
        } else if (e.key === "Escape") {
          e.preventDefault();
          onClose();
        }
      };

      return (
        <div
          ref={containerRef}
          style={{
            position: "absolute",
            left: x,
            top: y,
            zIndex: 9999,
            minWidth: 260,
            maxWidth: 360,
            background: "#fff",
            border: "1px solid #ddd",
            borderRadius: 6,
            boxShadow: "0 8px 24px rgba(0,0,0,0.12)",
            padding: 8,
            fontFamily:
              'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            fontSize: 13
          }}
        >
          <input
            ref={inputRef}
            value={query}
            onChange={(e) => {
              setQuery(e.target.value);
              setHighlightIndex(0);
            }}
            onKeyDown={handleKeyDown}
            placeholder="Search symbol or LaTeX…"
            style={{
              width: "100%",
              boxSizing: "border-box",
              padding: "4px 6px",
              marginBottom: 6,
              borderRadius: 4,
              border: "1px solid #ccc",
              outline: "none"
            }}
          />

          <div style={{ maxHeight: 260, overflowY: "auto" }}>
            {results.map((sym, idx) => (
              <div
                key={sym.latex + idx}
                style={{
                  display: "flex",
                  alignItems: "center",
                  padding: "4px 6px",
                  borderRadius: 4,
                  background: idx === highlightIndex ? "#eef3ff" : "transparent",
                  cursor: "pointer"
                }}
                onMouseDown={(e) => {
                  e.preventDefault();
                  onSelect(sym);
                }}
              >
                <span
                  style={{
                    width: 32,
                    textAlign: "center",
                    fontSize: 18,
                    marginRight: 6
                  }}
                >
                  {sym.label}
                </span>
                <div
                  style={{
                    display: "flex",
                    flexDirection: "column",
                    flex: 1,
                    overflow: "hidden"
                  }}
                >
                  <span
                    style={{
                      fontFamily: "monospace",
                      fontSize: 12,
                      whiteSpace: "nowrap",
                      overflow: "hidden",
                      textOverflow: "ellipsis"
                    }}
                  >
                    {sym.latex}
                  </span>
                  {sym.keywords && sym.keywords.length > 0 && (
                    <span
                      style={{
                        fontSize: 11,
                        color: "#777",
                        whiteSpace: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis"
                      }}
                    >
                      {sym.keywords.slice(0, 4).join(", ")}
                    </span>
                  )}
                </div>
              </div>
            ))}

            {results.length === 0 && (
              <div
                style={{
                  padding: "4px 6px",
                  fontSize: 12,
                  color: "#888"
                }}
              >
                No matches
              </div>
            )}
          </div>
        </div>
      );
    };

    const popupRoot = ReactDOM.createRoot(
      document.getElementById("symbol-popup-root")
    );

    window.showSymbolPopup = function ({ x, y, initialQuery, onSelect }) {
      const handleSelect = (symbol) => {
        // --- Update recent list (per session, in-memory) ---
        if (!Array.isArray(window.RECENT_SYMBOLS)) {
          window.RECENT_SYMBOLS = [];
        }
        const arr = window.RECENT_SYMBOLS;
        const latex = symbol.latex;

        // Remove if already present
        const existingIndex = arr.indexOf(latex);
        if (existingIndex !== -1) {
          arr.splice(existingIndex, 1);
        }
        // Add to front
        arr.unshift(latex);
        // Keep list bounded (e.g. last 30 unique symbols)
        if (arr.length > 30) {
          arr.length = 30;
        }

        // Pass selection back to caller (inserts in textarea, etc.)
        onSelect(symbol);

        // Close popup
        popupRoot.render(null);
      };

      const handleClose = () => {
        popupRoot.render(null);
      };

      popupRoot.render(
        <SymbolPopup
          x={x}
          y={y}
          initialQuery={initialQuery}
          onSelect={handleSelect}
          onClose={handleClose}
        />
      );
    };

  </script>

  <!-- Plain JS: MathJax, copy, canvas, and backslash-triggered popup -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Load symbols.json (same pattern as Logic Level 1)
      fetch("../symbols.json")
        .then((res) => res.json())
        .then((data) => {
          window.SYMBOLS = Array.isArray(data) ? data : (data.symbols || []);
          console.log("Loaded symbols:", window.SYMBOLS.length);
        })
        .catch((err) => {
          console.error("Failed to load symbols.json", err);
          window.SYMBOLS = [];
        });

      // Render textarea contents as *block* TeX and
      // auto-wrap multi-line input in a gather* environment.
      function renderBlockTeX(textarea, outputElement) {
        const raw = textarea.value.trim();
        if (!raw) {
          outputElement.innerHTML = "";
          return;
        }

        let tex = raw;

        const explicitDisplayOrEnv = /^(\$\$|\\\[|\\begin\{)/.test(raw);
        const looksMultiline = raw.includes("\\\\") || raw.includes("\n");

        if (!explicitDisplayOrEnv) {
          if (looksMultiline) {
            tex = "\\begin{gather*}\n" + raw + "\n\\end{gather*}";
          } else {
            tex = "\\[" + raw + "\\]";
          }
        }

        outputElement.textContent = tex;

        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise([outputElement]).catch(err => console.error(err));
        }
      }

      // Insert text into a textarea at the cursor position
      function insertAtCursor(textarea, text) {
        if (!textarea) return;
        const start = textarea.selectionStart ?? textarea.value.length;
        const end   = textarea.selectionEnd ?? textarea.value.length;
        const value = textarea.value;

        textarea.value = value.slice(0, start) + text + value.slice(end);
        const newPos = start + text.length;

        textarea.focus();
        textarea.selectionStart = textarea.selectionEnd = newPos;
        textarea.dispatchEvent(new Event("input", { bubbles: true }));
      }

      /* --------- Note board: LaTeX area ---------- */
      const noteTextarea = document.getElementById("note-latex");
      const noteRender   = document.getElementById("note-render");
      const copyNotesBtn = document.getElementById("copy-notes");

      function renderNotes() {
        renderBlockTeX(noteTextarea, noteRender);
      }

      noteTextarea.addEventListener("input", renderNotes);

      copyNotesBtn.addEventListener("click", async () => {
        const latex = noteTextarea.value.trim();
        const content = "Notes (LaTeX):\n" + latex + "\n";
        try {
          await navigator.clipboard.writeText(content);
          copyNotesBtn.classList.add("copied");
          setTimeout(() => copyNotesBtn.classList.remove("copied"), 1200);
        } catch (err) {
          console.error("Clipboard error:", err);
          alert("Copy failed – your browser may block clipboard access.");
        }
      });

      // ---------- Backslash shortcut → symbol popup (same as Level 1) ----------
      function openPopupAtTextareaCursor(ta) {
        const rect = ta.getBoundingClientRect();
        const x = rect.left + window.scrollX + 40;
        const y = rect.top + window.scrollY + 20;

        const pos = ta.selectionStart != null ? ta.selectionStart : ta.value.length;
        const value = ta.value;

        let initialQuery = "";
        const lastBackslash = value.lastIndexOf("\\", pos - 1);
        if (lastBackslash !== -1 && lastBackslash < pos) {
          initialQuery = value.slice(lastBackslash + 1, pos);
        }

        if (window.showSymbolPopup) {
          window.showSymbolPopup({
            x,
            y,
            initialQuery,
            onSelect(symbol) {
              insertAtCursor(ta, symbol.latex);
            }
          });
        }
      }

      let lastBackslashTime = 0;

      noteTextarea.addEventListener("keydown", (e) => {
        if (e.key === "\\") {
          const now = Date.now();

          if (now - lastBackslashTime < 250) {
            e.preventDefault(); // don't type this second "\"

            const pos = noteTextarea.selectionStart != null
              ? noteTextarea.selectionStart
              : noteTextarea.value.length;
            const value = noteTextarea.value;

            if (pos > 0 && value[pos - 1] === "\\") {
              noteTextarea.value = value.slice(0, pos - 1) + value.slice(pos);
              noteTextarea.selectionStart = noteTextarea.selectionEnd = pos - 1;
              noteTextarea.dispatchEvent(new Event("input", { bubbles: true }));
            }

            openPopupAtTextareaCursor(noteTextarea);
            lastBackslashTime = 0;
            return;
          }

          lastBackslashTime = now;
        }
      });

      /* --------- Note board: drawing canvas ---------- */
      const canvas = document.getElementById("note-canvas");
      const clearBtn = document.getElementById("clear-canvas");
      const ctx = canvas.getContext("2d");

      function resizeCanvas() {
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;

        ctx.setTransform(1, 0, 0, 1, 0, 0);

        canvas.width  = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.lineWidth = 2;
      }

      resizeCanvas();
      window.addEventListener("resize", resizeCanvas);

      let drawing = false;
      let lastX = 0;
      let lastY = 0;

      function getPos(evt) {
        const rect = canvas.getBoundingClientRect();
        if (evt.touches && evt.touches[0]) {
          return {
            x: evt.touches[0].clientX - rect.left,
            y: evt.touches[0].clientY - rect.top
          };
        } else {
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
          };
        }
      }

      function startDraw(evt) {
        evt.preventDefault();
        drawing = true;
        const pos = getPos(evt);
        lastX = pos.x;
        lastY = pos.y;
      }

      function draw(evt) {
        if (!drawing) return;
        evt.preventDefault();
        const pos = getPos(evt);
        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        lastX = pos.x;
        lastY = pos.y;
      }

      function endDraw(evt) {
        if (!drawing) return;
        evt.preventDefault();
        drawing = false;
      }

      canvas.addEventListener("mousedown", startDraw);
      canvas.addEventListener("mousemove", draw);
      window.addEventListener("mouseup", endDraw);

      canvas.addEventListener("touchstart", startDraw, {passive: false});
      canvas.addEventListener("touchmove", draw, {passive: false});
      canvas.addEventListener("touchend", endDraw, {passive: false});
      canvas.addEventListener("touchcancel", endDraw, {passive: false});

      clearBtn.addEventListener("click", () => {
        const rect = canvas.getBoundingClientRect();
        ctx.clearRect(0, 0, rect.width, rect.height);
      });
    });
  </script>
</body>
</html>
