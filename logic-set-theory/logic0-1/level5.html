<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Logic 0 ‚Äì Level 5</title>

  <!-- Basic layout styles -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }

    header {
      background: #222;
      color: #fff;
      padding: 1rem 1.5rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.6rem;
    }

    main {
      max-width: 900px;
      margin: 1.5rem auto 3rem;
      padding: 0 1rem 2rem;
      background: #fff;
      box-shadow: 0 0.5rem 1rem rgba(0,0,0,0.08);
      border-radius: 8px;
    }

    section {
      margin-bottom: 2rem;
    }

    h2 {
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    h3 {
      margin-top: 1rem;
      margin-bottom: 0.4rem;
      font-size: 1.1rem;
    }

    .note {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 0.8rem;
    }

    .problem-group {
      border-top: 1px solid #eee;
      padding-top: 1.25rem;
      margin-top: 1.25rem;
    }

    .problem-group:first-of-type {
      border-top: none;
      padding-top: 0;
      margin-top: 0.5rem;
    }

    .latex-input {
      width: 100%;
      min-height: 70px;
      padding: 0.5rem;
      font-family: "Fira Code", "JetBrains Mono", Menlo, Monaco,
                   Consolas, "Courier New", monospace;
      font-size: 0.95rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      resize: vertical;
      margin-bottom: 0.5rem;
    }

    .rendered-output {
      min-height: 2rem;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px dashed #ccc;
      background: #fafafa;
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .rendered-output mjx-container {
      display: inline-block;
      margin-left: auto;
      margin-right: auto;
    }

    .controls {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-bottom: 0.3rem;
    }

    .copy-btn {
      padding: 0.3rem 0.7rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #333;
      color: #fff;
      font-size: 0.9rem;
    }

    .copy-btn:active {
      transform: scale(0.97);
    }

    .copy-btn.copied::after {
      content: " ‚úì";
    }

    .canvas-wrapper {
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      background: #fff;
    }

    .canvas-block {
      margin-top: 0.75rem;
    }

    .note-canvas {
      display: block;
      width: 100%;
      height: 250px;
      touch-action: none; /* for better touch drawing */
    }

    .clear-canvas {
      margin-top: 0.4rem;
    }



  </style>

  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        packages: { "[+]": ["ams"] },
        inlineMath: [["\\(","\\)"], ["$","$"]],
        displayMath: [["\\[","\\]"], ["$$","$$"]]
      },
      svg: { fontCache: "global" }
    };
  </script>

  <script id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
          async></script>
</head>
<body>
  <header>
    <h1>Logic 0 ‚Äì Level 5 Problems</h1>
  </header>

<main>
  <section>
    <p class="note">
      Level 5 (<strong>Evaluate</strong>) problems ask you to <em>make a judgment</em>:
      accept or reject a claim, compare alternatives, justify which definition or convention
      is better and why. Use the LaTeX notes area and drawing pad under each group to
      structure your arguments.
    </p>
  </section>

  <!-- 1. Preliminaries and Notation -->
  <section class="problem-group" id="group-1">
    <h2>1. Preliminaries and Notation</h2>

    <p><strong>(E1.1)</strong>
      Two ways to translate ‚Äú\(P\) only if \(Q\)‚Äù into symbols are:
    </p>
    <ul>
      <li>(a) \(P \Rightarrow Q\)</li>
      <li>(b) \(Q \Leftarrow P\)</li>
    </ul>
    <p>
      Evaluate whether (a) and (b) are genuinely equivalent in the sense of Remark 1.1. Defend
      one of these possibilities, with reasons:
    </p>
    <ol>
      <li>They are always equivalent.</li>
      <li>They differ in subtle but important ways.</li>
    </ol>
    <p>
      Back up your verdict with explicit examples and a clear argument using the conventions of
      the notes.
    </p>

    <p><strong>(E1.2)</strong>
      A student claims:
    </p>
    <blockquote>
      ‚ÄúInstead of introducing a special symbol \(\Sigma \not\models \tau\), we should always
      write \(\Sigma \models \neg \tau\) for the negation of \(\Sigma \models \tau\).‚Äù
    </blockquote>
    <p>
      Using the negation rule in Remark 1.2 and the intended reading of \(\models\), evaluate
      this proposal:
    </p>
    <ul>
      <li>Is \(\Sigma \not\models \tau\) equivalent to \(\Sigma \models \neg \tau\) in general?</li>
      <li>
        Give a reasoned judgment, with either a convincing argument for equivalence or a
        counterexample-style scenario where they differ.
      </li>
    </ul>

    <p><strong>(E1.3)</strong>
      The notes adopt a ‚Äúnegation by slashing symbols‚Äù convention (e.g.
      \(x = y \Rightarrow x \neq y\), \(x \in A \Rightarrow x \notin A\)). Evaluate this design
      choice:
    </p>
    <ul>
      <li>
        Give at least one <em>advantage</em> and one <em>potential drawback</em> of this
        convention compared with always writing ‚Äú\(\neg(x = y)\)‚Äù or ‚Äú\(\neg(x\in A)\)‚Äù.
      </li>
      <li>
        In your judgment, is this convention more clarifying or more likely to create
        confusion? Defend your view.
      </li>
    </ul>

    <!-- Notes + drawing for group 1 -->
    <div class="group-notes">
      <h3>Notes for Group 1</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. translate &quot;only if&quot;, analyze Œ£ ‚ä≠ œÑ vs Œ£ ‚ä® ¬¨œÑ, pros/cons of slashed negation"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use to sketch truth tables or counterexamples.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 2. Sets and the Extensionality Principle -->
  <section class="problem-group" id="group-2">
    <h2>2. Sets and the Extensionality Principle</h2>

    <p><strong>(E2.1)</strong>
      Someone proposes the following as a <em>definition</em> of equality of sets:
    </p>
    <blockquote>
      ‚ÄúTwo sets \(A\) and \(B\) are equal iff: (i) \(A\subseteq B\) and (ii) \(B\subseteq A\).‚Äù
    </blockquote>
    <p>
      Compare this with Proposition 2.3 (Extensionality:
      \(\forall t(t\in A \Leftrightarrow t\in B) \Rightarrow A=B\)). Evaluate whether the proposed
      definition is:
    </p>
    <ol>
      <li>Completely equivalent to the extensionality-based characterization,</li>
      <li>Strictly weaker/stronger, or</li>
      <li>Somehow circular or problematic.</li>
    </ol>
    <p>
      Give a detailed justification, explicitly unpacking the meanings of ‚Äúsubset‚Äù and
      ‚Äú\(\forall t(t\in A \Leftrightarrow t\in B)\)‚Äù.
    </p>

    <p><strong>(E2.2)</strong>
      A classmate says:
    </p>
    <blockquote>
      ‚ÄúExtensionality (Proposition 2.3) is just obvious set-theoretic common sense, so it isn‚Äôt
      necessary to state or use it explicitly.‚Äù
    </blockquote>
    <p>
      Evaluate this claim. In your answer:
    </p>
    <ul>
      <li>
        Identify at least one place in the notes where Extensionality (or its converse in Remark
        2.2) is <em>actually doing work</em>.
      </li>
      <li>
        Argue whether those arguments would still be valid if extensionality were not taken as a
        principle.
      </li>
    </ul>

    <!-- Notes + drawing for group 2 -->
    <div class="group-notes">
      <h3>Notes for Group 2</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. unfold A‚äÜB, B‚äÜA, compare to ‚àÄt(t‚ààA ‚áî t‚ààB), find where Extensionality is used"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for Venn-style sketches or implication diagrams.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 3. Basic Constructions ‚Äì Adjoining an Element -->
  <section class="problem-group" id="group-3">
    <h2>3. Basic Constructions ‚Äì Adjoining an Element</h2>

    <p><strong>(E3.1)</strong>
      Definition 3.1 sets \(A;t := A \cup \{t\}\) and Proposition 3.2 characterizes when
      \(A;t = A\). Suppose an alternative convention is proposed:
    </p>
    <blockquote>
      ‚ÄúDefine \(A;t\) only when \(t\notin A\); otherwise leave \(A;t\) undefined.‚Äù
    </blockquote>
    <p>
      Evaluate this alternative from the standpoint of:
    </p>
    <ol>
      <li>Mathematical convenience (e.g. in proofs and constructions).</li>
      <li>Conceptual clarity about what it means to ‚Äòadjoin‚Äô an element.</li>
      <li>Compatibility with Proposition 3.2.</li>
    </ol>
    <p>Make a reasoned case for which convention (notes vs. alternative) is better.</p>

    <p><strong>(E3.2)</strong>
      Consider building a finite set by repeated adjoining starting from \(\varnothing\). Two
      students propose different descriptions:
    </p>
    <ul>
      <li>
        Student A: ‚ÄúEvery finite set can be obtained this way, and the order in which you adjoin
        elements never matters.‚Äù
      </li>
      <li>
        Student B: ‚ÄúThe order sometimes matters because \(\varnothing;a;b\) could differ from
        \(\varnothing;b;a\).‚Äù
      </li>
    </ul>
    <p>
      Evaluate who is correct, using the definitions of ‚Äúfinite list of objects‚Äù and the notion
      of set equality. Support your judgment with a rigorous argument or counterexample.
    </p>

    <!-- Notes + drawing for group 3 -->
    <div class="group-notes">
      <h3>Notes for Group 3</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. compare total vs partial definition of A;t, analyze {a,b} via different orders"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for chains ‚àÖ ‚äÜ {a} ‚äÜ {a,b} etc.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 4. Common Sets and Notation -->
  <section class="problem-group" id="group-4">
    <h2>4. Common Sets and Notation</h2>

    <p><strong>(E4.1)</strong>
      Definition 4.3 takes \(\mathbb{N} = \{0,1,2,\dots\}\). Some authors prefer
      \(\{1,2,3,\dots\}\).
    </p>
    <p>
      Evaluate the choice made in the notes:
    </p>
    <ul>
      <li>
        Give at least two concrete situations (using material in this PDF) where including 0 in
        \(\mathbb{N}\) simplifies statements or proofs.
      </li>
      <li>
        Mention at least one context where this convention might cause friction when comparing
        with other texts.
      </li>
      <li>
        Conclude with your judgment on whether this is a good foundational choice for a first
        logic/set theory chapter.
      </li>
    </ul>

    <p><strong>(E4.2)</strong>
      Remark 4.2 says \(\{x,y\} = \{y,x\}\) because ‚Äúorder does not matter for sets.‚Äù Evaluate
      how essential this remark is for the later development:
    </p>
    <ul>
      <li>
        Identify a later definition or proposition (e.g. about ordered pairs) that <em>relies</em>
        on distinguishing ordered vs unordered collections.
      </li>
      <li>
        Argue whether suppressing or skipping Remark 4.2 would risk conceptual confusion between
        sets and ordered pairs.
      </li>
    </ul>

    <!-- Notes + drawing for group 4 -->
    <div class="group-notes">
      <h3>Notes for Group 4</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. examples where 0‚àà‚Ñï helps, where it clashes, importance of {x,y}={y,x} vs ‚ü®x,y‚ü©"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for comparing conventions across texts.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 5. Sets Specified by Properties ‚Äì Set-builder Notation -->
  <section class="problem-group" id="group-5">
    <h2>5. Sets Specified by Properties ‚Äì Set-builder Notation</h2>

    <p><strong>(E5.1)</strong>
      Compare the following notations:
    </p>
    <ol>
      <li>\(\{x\in A \mid P(x)\}\)</li>
      <li>\(\{x \mid x\in A \text{ and } P(x)\}\)</li>
    </ol>
    <p>
      Evaluate whether (1) and (2) are interchangeable in practice within this chapter. Your
      answer should:
    </p>
    <ul>
      <li>
        Identify any subtle advantages of (1) over (2) or vice versa (readability, scoping of
        variables, etc.).
      </li>
      <li>
        Argue whether a careful reader should treat them as notational variants of the
        <em>same</em> underlying idea.
      </li>
    </ul>

    <p><strong>(E5.2)</strong>
      A student uses set-builder notation to define:
    </p>
    <p>\[
      C = \{x \mid x\in \mathbb{N},\ x &lt; 0\}.
    \]</p>
    <p>
      Evaluate whether this is a ‚Äúgood definition‚Äù of a set in the sense of Definition 5.1:
    </p>
    <ul>
      <li>Is the property \(P(x)\) precise enough?</li>
      <li>Does this construction actually define a set, and if so, which one?</li>
      <li>
        From the point of view of the notes, is this legitimate or misleading usage? Justify your
        judgment.
      </li>
    </ul>

    <!-- Notes + drawing for group 5 -->
    <div class="group-notes">
      <h3>Notes for Group 5</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. compare {x‚ààA | P(x)} vs {x | x‚ààA and P(x)}, analyze C={x‚àà‚Ñï | x&lt;0}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for property diagrams or truth tables for P(x).</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 6. Subsets and Power Sets -->
  <section class="problem-group" id="group-6">
    <h2>6. Subsets and Power Sets</h2>

    <p><strong>(E6.1)</strong>
      Consider the statement:
    </p>
    <blockquote>
      ‚ÄúIf \(\mathcal{P}(A) = \mathcal{P}(B)\), then \(A = B\).‚Äù
    </blockquote>
    <p>
      Evaluate this statement using the definitions of subset and power set (Definition 6.1 and
      6.3) and the extensionality idea. Decide whether you accept or reject it, and defend your
      verdict with a full argument.
    </p>

    <p><strong>(E6.2)</strong>
      Remark 6.2 calls ‚Äú\(\varnothing \subseteq A\)‚Äù <em>vacuously true</em>. Some people find
      this unsatisfying or ‚Äúcheating.‚Äù
    </p>
    <p>
      Evaluate the role of vacuous truth here:
    </p>
    <ul>
      <li>
        Explain why rejecting vacuous truth would break some of the later statements about power
        sets and unions/intersections of families.
      </li>
      <li>
        On balance, argue whether the vacuous-truth convention is philosophically acceptable and
        mathematically necessary in this framework.
      </li>
    </ul>

    <!-- Notes + drawing for group 6 -->
    <div class="group-notes">
      <h3>Notes for Group 6</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. argue P(A)=P(B) ‚áí A=B, role of ‚àÖ‚äÜA and vacuous truth in later theorems"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for reasoning about P(A), P(B) and subset chains.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 7. Union and Intersection (Families of Sets) -->
  <section class="problem-group" id="group-7">
    <h2>7. Union and Intersection (Families of Sets)</h2>

    <p><strong>(E7.1)</strong>
      An alternative ‚Äúdefinition‚Äù of union and intersection of two sets is mistakenly proposed:
    </p>
    <p>\[
      A \cup' B = \{x \mid x\in A \text{ and } x\in B\},\quad
      A \cap' B = \{x \mid x\in A \text{ or } x\in B\}.
    \]</p>
    <p>
      Evaluate this swapped definition against Definition 7.1:
    </p>
    <ul>
      <li>
        Identify at least two concrete examples where using \(\cup',\cap'\) instead of
        \(\cup,\cap\) would seriously distort results.
      </li>
      <li>
        Explain why the correct choice of ‚Äúor‚Äù vs ‚Äúand‚Äù is not merely a convention but
        structurally essential.
      </li>
    </ul>

    <p><strong>(E7.2)</strong>
      For a family of sets \(A\) (whose elements are themselves sets), Definition 7.3 introduces
      \(\bigcup A\) and \(\bigcap A\). Some authors insist that \(\bigcap A\) should only be
      defined when \(A\neq \varnothing\) and \(\bigcup A\) when \(A\neq \varnothing\).
    </p>
    <p>
      Evaluate the decision in the notes:
    </p>
    <ul>
      <li>Should \(\bigcup \varnothing\) and \(\bigcap \varnothing\) be left undefined in this framework?</li>
      <li>
        Using the style of definitions in the chapter, argue for one of the following positions:
        <ul>
          <li>They <em>must</em> be defined (and suggest what they should be), or</li>
          <li>It is better to leave them undefined.</li>
        </ul>
      </li>
      <li>Support your position with logical and practical considerations.</li>
    </ul>

    <!-- Notes + drawing for group 7 -->
    <div class="group-notes">
      <h3>Notes for Group 7</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. test A‚à™'B vs A‚à©'B on examples, reason about ‚ãÉ‚àÖ and ‚ãÇ‚àÖ definitions/choices"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for Venn diagrams and family-of-sets behavior.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 8. Ordered Pairs and Sequences -->
  <section class="problem-group" id="group-8">
    <h2>8. Ordered Pairs and Sequences</h2>

    <p><strong>(E8.1)</strong>
      Kuratowski defines \(\langle x,y\rangle := \{\{x\},\{x,y\}\}\), and Proposition 8.2 shows
      this behaves correctly as an ordered pair. Evaluate this choice:
    </p>
    <ul>
      <li>
        Compare Kuratowski‚Äôs definition with the informal idea that ‚Äú\(\langle x,y\rangle\) is just
        a primitive object with first coordinate \(x\) and second coordinate \(y\).‚Äù
      </li>
      <li>
        Argue whether the set-theoretic definition adds real value in this chapter, given the
        later use in Cartesian products and relations, or whether it is an unnecessary
        complication for beginners.
      </li>
    </ul>

    <p><strong>(E8.2)</strong>
      Lemma 8.5 (Lemma 0A) and Corollary 8.7 are somewhat technical results about sequences.
      Evaluate their necessity:
    </p>
    <ul>
      <li>
        Identify at least one later definition or fact (e.g. about \(A^n\), n-ary relations, or
        functions) whose <em>rigor</em> depends on the uniqueness of tuple decomposition.
      </li>
      <li>
        Give a judgment: is it worth introducing such a technical lemma this early, or could the
        chapter have safely hand-waved this? Defend your answer.
      </li>
    </ul>

    <!-- Notes + drawing for group 8 -->
    <div class="group-notes">
      <h3>Notes for Group 8</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. pros/cons of Kuratowski pairs, where Lemma 0A is used for A‚Åø, relations, functions"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for visualizing ordered pairs vs primitive black boxes.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 9. Cartesian Products and Relations -->
  <section class="problem-group" id="group-9">
    <h2>9. Cartesian Products and Relations</h2>

    <p><strong>(E9.1)</strong>
      Definition 9.1 gives \(A\times B = \{\langle x,y\rangle \mid x\in A, y\in B\}\). Someone
      suggests:
    </p>
    <blockquote>
      ‚ÄúWe don‚Äôt need ordered pairs; we can perfectly well define \(A\times B\) as the set of all
      two-element subsets \(\{x,y\}\) with \(x\in A\), \(y\in B\).‚Äù
    </blockquote>
    <p>
      Evaluate this suggestion:
    </p>
    <ul>
      <li>
        Give a precise argument why this alternative either fails or succeeds in representing all
        the structural information needed for binary relations and functions as developed in
        Section 9‚Äì10.
      </li>
      <li>
        Give your overall judgment on whether Kuratowski pairs are essential for the later theory
        in this chapter.
      </li>
    </ul>

    <p><strong>(E9.2)</strong>
      Definition 9.2 calls a relation ‚Äúa set of ordered pairs,‚Äù while Definition 9.5 later says
      ‚Äúan \(n\)-ary relation on \(A\) is a subset of \(A^n\).‚Äù Evaluate the consistency of these
      two viewpoints:
    </p>
    <ul>
      <li>Are these essentially two perspectives on the same idea, or is there a real conceptual shift?</li>
      <li>
        Argue whether the chapter‚Äôs sequence of definitions (binary first, then n-ary) is
        logically clean and pedagogically sound, or whether it could mislead a careful reader.
      </li>
    </ul>

    <!-- Notes + drawing for group 9 -->
    <div class="group-notes">
      <h3>Notes for Group 9</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. test {x,y} vs ‚ü®x,y‚ü© in functions, compare &quot;set of pairs&quot; vs &quot;subset of A‚Åø&quot;"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for diagrams of A√óB and relation arity.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 10. Functions and Operations -->
  <section class="problem-group" id="group-10">
    <h2>10. Functions and Operations</h2>

    <p><strong>(E10.1)</strong>
      A student writes:
    </p>
    <blockquote>
      ‚ÄúA function \(F:A\to B\) is just any relation with \(\operatorname{dom}(F)=A\) and
      \(\operatorname{ran}(F)\subseteq B\).‚Äù
    </blockquote>
    <p>
      Compare this with Definition 10.1 (the ‚Äúexactly one output for each input‚Äù condition) and
      evaluate the student‚Äôs definition:
    </p>
    <ul>
      <li>Does it fully capture the intended notion of function?</li>
      <li>
        If not, identify precisely what is missing and give a counterexample relation that
        satisfies the student‚Äôs condition but fails to be a function in the sense of the notes.
      </li>
    </ul>

    <p><strong>(E10.2)</strong>
      Definition 10.2 requires an \(n\)-ary operation on \(A\) to be a function
      \(f:A^n\to A\) (codomain \(A\) again). Some might argue it‚Äôs enough to require a function
      \(f:A^n\to B\) for some set \(B\).
    </p>
    <p>
      Evaluate this alternative:
    </p>
    <ul>
      <li>
        Using the examples of addition and successor on \(\mathbb{N}\), explain why requiring the
        codomain to be \(A\) itself is more than a cosmetic choice.
      </li>
      <li>
        Decide whether the ‚Äúoperation on \(A\)‚Äù viewpoint is worth the extra restriction in this
        chapter.
      </li>
    </ul>

    <!-- Notes + drawing for group 10 -->
    <div class="group-notes">
      <h3>Notes for Group 10</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. find relation with dom(F)=A, ran(F)‚äÜB but not single-valued; analyze f:A‚Åø‚ÜíA vs f:A‚Åø‚ÜíB"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for mapping diagrams and closure pictures.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 11. Standard Classes of Relations -->
  <section class="problem-group" id="group-11">
    <h2>11. Standard Classes of Relations</h2>

    <p><strong>(E11.1)</strong>
      Definitions 11.1‚Äì11.3 (reflexive, symmetric, transitive, trichotomy; equivalence
      relations; ordering relations) carve out two big families of ‚Äúnice‚Äù relations. Evaluate
      this classification scheme:
    </p>
    <ul>
      <li>
        Argue whether it is reasonable to treat <em>equivalence relations</em> and
        <em>ordering relations</em> as the two central ‚Äúwell-behaved‚Äù relation types in
        elementary set/logic texts.
      </li>
      <li>
        Suggest one property or relation-type that might deserve equal prominence but is not
        singled out here, and justify your suggestion.
      </li>
    </ul>

    <p><strong>(E11.2)</strong>
      You are given two relations on \(\mathbb{Z}\):
    </p>
    <ul>
      <li>\(a \sim b\) iff \(a-b\) is divisible by 2,</li>
      <li>\(a \prec b\) iff \(a&lt;b\).</li>
    </ul>
    <p>
      Evaluate the decision (in the notes) to classify the first as an equivalence relation and
      the second as an ordering relation:
    </p>
    <ul>
      <li>
        Explain how the <em>behaviour</em> of equivalence classes under \(\sim\) qualitatively
        differs from the behaviour of chains under \(\prec\).
      </li>
      <li>
        Assess whether this contrast justifies treating equivalence and order as fundamentally
        different archetypes, rather than variations of the same idea.
      </li>
    </ul>

    <!-- Notes + drawing for group 11 -->
    <div class="group-notes">
      <h3>Notes for Group 11</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. defend focus on equivalence + order, propose other &quot;nice&quot; relation types, compare classes vs chains"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for diagrams of equivalence classes and ordered chains.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 12. Equivalence Classes -->
  <section class="problem-group" id="group-12">
    <h2>12. Equivalence Classes</h2>

    <p><strong>(E12.1)</strong>
      Proposition 12.2 states that equivalence classes of an equivalence relation form a
      partition of \(A\), and conversely that being in the same class is equivalent to being
      related. Evaluate this result:
    </p>
    <ul>
      <li>
        Argue how much of the ‚Äúmeaning‚Äù of an equivalence relation is already captured by its set
        of equivalence classes.
      </li>
      <li>
        Decide whether, in the context of this chapter, it would be cleaner to <em>define</em>
        equivalence relations in terms of partitions rather than reflexive/symmetric/transitive
        properties. Defend your answer.
      </li>
    </ul>

    <p><strong>(E12.2)</strong>
      Suppose someone defines a relation \(R\) on a set \(A\) that is <em>symmetric</em> and
      <em>transitive</em> but not reflexive.
    </p>
    <ul>
      <li>Evaluate whether the usual language of ‚Äúequivalence classes of \(R\)‚Äù still makes sense.</li>
      <li>
        In your judgment, is reflexivity a merely technical condition, or does dropping it
        fundamentally change the status of the ‚Äúclasses‚Äù
        \([x] = \{y\in A \mid \langle x,y\rangle\in R\}\)?
      </li>
      <li>
        Support your view by carefully analyzing which parts of Proposition 12.2 break if
        reflexivity is removed.
      </li>
    </ul>

    <!-- Notes + drawing for group 12 -->
    <div class="group-notes">
      <h3>Notes for Group 12</h3>
      <div class="note">Type \\ quickly to open LaTeX snippet app on the note.</div>
      <textarea class="latex-input"
        placeholder="e.g. equivalence via partitions vs properties, what fails if R is not reflexive"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for partition diagrams and &quot;almost-equivalence&quot; examples.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>
</main>


  <!-- Root for the React symbol popup -->
  <div id="symbol-popup-root"></div>

  <!-- React + ReactDOM + Babel (for JSX in this example) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- React + JSX: ONLY the popup component + showSymbolPopup -->
  <script type="text/babel" data-presets="env,react">
    // ---------- Symbol data (you can expand this later) ----------
    window.SYMBOLS = [];
    window.RECENT_SYMBOLS = [];

    // ---------- Simple search ----------
    function searchSymbols(symbols, query) {
      const q = query.trim().toLowerCase();

      const recentList = Array.isArray(window.RECENT_SYMBOLS)
        ? window.RECENT_SYMBOLS
        : [];
      const recentSet = new Set(recentList);

      // ---------- Case 1: empty query ‚Üí show recent first ----------
      if (!q) {
        const seen = new Set();
        const recent = [];
        const others = [];

        // 1) Put recents first, in recency order
        for (const latex of recentList) {
          const sym = symbols.find((s) => s.latex === latex);
          if (sym && !seen.has(sym.latex)) {
            recent.push(sym);
            seen.add(sym.latex);
          }
        }

        // 2) Then all other symbols, sorted by priority
        for (const s of symbols) {
          if (!seen.has(s.latex)) {
            others.push(s);
          }
        }

        others.sort((a, b) => (b.priority || 0) - (a.priority || 0));

        return [...recent, ...others].slice(0, 20);
      }

      // ---------- Case 2: non-empty query ‚Üí scoring with recency boost ----------
      return symbols
        .map((s) => {
          const haystack = [
            s.label,
            s.latex,
            ...(s.keywords || []),
            ...(s.categories || [])
          ].join(" ").toLowerCase();

          if (!haystack.includes(q)) return null;

          let score = s.priority || 0;

          // Strong boost if this is a recent symbol
          const recIndex = recentList.indexOf(s.latex);
          if (recIndex !== -1) {
            const recencyWeight = 1.0 + (recentList.length - recIndex) * 0.05;
            score += recencyWeight;
          }

          if (s.latex.toLowerCase().startsWith("\\" + q)) score += 0.7;
          if ((s.keywords || []).some((k) => k.toLowerCase() === q)) score += 0.5;
          if (s.label.toLowerCase() === q) score += 0.4;

          const idx = haystack.indexOf(q);
          if (idx >= 0) score += Math.max(0, 0.3 - idx / 50);

          return { s, score };
        })
        .filter(Boolean)
        .sort((a, b) => b.score - a.score)
        .map((x) => x.s)
        .slice(0, 20);
    }


    // ---------- React popup component ----------
    const SymbolPopup = ({ x, y, initialQuery = "", onSelect, onClose }) => {
        const [query, setQuery] = React.useState("");
        const [highlightIndex, setHighlightIndex] = React.useState(0);
        const containerRef = React.useRef(null);
        const inputRef = React.useRef(null);

        const results = React.useMemo(
          () => searchSymbols(window.SYMBOLS || [], query),
          [query]
        );

        React.useEffect(() => {
          if (inputRef.current) {
            setTimeout(() => inputRef.current.focus(), 0);
          }
        }, []);

      React.useEffect(() => {
        if (inputRef.current) {
          setTimeout(() => inputRef.current.focus(), 0);
        }
      }, []);

      React.useEffect(() => {
        function handleClickOutside(e) {
          if (!containerRef.current) return;
          if (!containerRef.current.contains(e.target)) {
            onClose();
          }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
      }, [onClose]);

      const handleKeyDown = (e) => {
        const count = results.length;
        if (e.key === "ArrowDown") {
          e.preventDefault();
          if (count === 0) return;
          setHighlightIndex((prev) => (prev + 1) % count);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (count === 0) return;
          setHighlightIndex((prev) => (prev - 1 + count) % count);
        } else if (e.key === "Enter") {
          e.preventDefault();
          if (count === 0) return;
          onSelect(results[highlightIndex]);
        } else if (e.key === "Escape") {
          e.preventDefault();
          onClose();
        }
      };

      return (
        <div
          ref={containerRef}
          style={{
            position: "absolute",
            left: x,
            top: y,
            zIndex: 9999,
            minWidth: 260,
            maxWidth: 360,
            background: "#fff",
            border: "1px solid #ddd",
            borderRadius: 6,
            boxShadow: "0 8px 24px rgba(0,0,0,0.12)",
            padding: 8,
            fontFamily:
              'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            fontSize: 13
          }}
        >
          <input
            ref={inputRef}
            value={query}
            onChange={(e) => {
              setQuery(e.target.value);
              setHighlightIndex(0);
            }}
            onKeyDown={handleKeyDown}
            placeholder="Search symbol or LaTeX‚Ä¶"
            style={{
              width: "100%",
              boxSizing: "border-box",
              padding: "4px 6px",
              marginBottom: 6,
              borderRadius: 4,
              border: "1px solid #ccc",
              outline: "none"
            }}
          />

          <div style={{ maxHeight: 260, overflowY: "auto" }}>
            {results.map((sym, idx) => (
              <div
                key={sym.latex + idx}
                style={{
                  display: "flex",
                  alignItems: "center",
                  padding: "4px 6px",
                  borderRadius: 4,
                  background: idx === highlightIndex ? "#eef3ff" : "transparent",
                  cursor: "pointer"
                }}
                onMouseDown={(e) => {
                  e.preventDefault();
                  onSelect(sym);
                }}
              >
                <span
                  style={{
                    width: 32,
                    textAlign: "center",
                    fontSize: 18,
                    marginRight: 6
                  }}
                >
                  {sym.label}
                </span>
                <div
                  style={{
                    display: "flex",
                    flexDirection: "column",
                    flex: 1,
                    overflow: "hidden"
                  }}
                >
                  <span
                    style={{
                      fontFamily: "monospace",
                      fontSize: 12,
                      whiteSpace: "nowrap",
                      overflow: "hidden",
                      textOverflow: "ellipsis"
                    }}
                  >
                    {sym.latex}
                  </span>
                  {sym.keywords && sym.keywords.length > 0 && (
                    <span
                      style={{
                        fontSize: 11,
                        color: "#777",
                        whiteSpace: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis"
                      }}
                    >
                      {sym.keywords.slice(0, 4).join(", ")}
                    </span>
                  )}
                </div>
              </div>
            ))}

            {results.length === 0 && (
              <div
                style={{
                  padding: "4px 6px",
                  fontSize: 12,
                  color: "#888"
                }}
              >
                No matches
              </div>
            )}
          </div>
        </div>
      );
    };

    // ---------- Helper: show popup from vanilla JS ----------
    const popupRoot = ReactDOM.createRoot(
      document.getElementById("symbol-popup-root")
    );

    window.showSymbolPopup = function ({ x, y, initialQuery, onSelect }) {
      const handleSelect = (symbol) => {
        // --- Update recent list (per session, in-memory) ---
        if (!Array.isArray(window.RECENT_SYMBOLS)) {
          window.RECENT_SYMBOLS = [];
        }
        const arr = window.RECENT_SYMBOLS;
        const latex = symbol.latex;

        // Remove if already present
        const existingIndex = arr.indexOf(latex);
        if (existingIndex !== -1) {
          arr.splice(existingIndex, 1);
        }
        // Add to front
        arr.unshift(latex);
        // Keep list bounded (e.g. last 30 unique symbols)
        if (arr.length > 30) {
          arr.length = 30;
        }

        // Pass selection back to caller (inserts in textarea, etc.)
        onSelect(symbol);

        // Close popup
        popupRoot.render(null);
      };

      const handleClose = () => {
        popupRoot.render(null);
      };

      popupRoot.render(
        <SymbolPopup
          x={x}
          y={y}
          initialQuery={initialQuery}
          onSelect={handleSelect}
          onClose={handleClose}
        />
      );
    };

  </script>

  <!-- Plain JS: MathJax rendering, copy, canvas, backslash trigger -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Load symbols.json
      fetch("../../symbols.json")
        .then((res) => res.json())
        .then((data) => {
          window.SYMBOLS = Array.isArray(data) ? data : (data.symbols || []);
          console.log("Loaded symbols:", window.SYMBOLS.length);
        })
        .catch((err) => {
          console.error("Failed to load symbols.json", err);
          window.SYMBOLS = [];
        });

      function renderBlockTeX(textarea, outputElement) {
        const raw = textarea.value.trim();
        if (!raw) {
          if (outputElement) outputElement.innerHTML = "";
          return;
        }

        let tex = raw;
        const explicitDisplayOrEnv = /^(\$\$|\\\[|\\begin\{)/.test(raw);
        const looksMultiline = raw.includes("\\\\") || raw.includes("\n");

        if (!explicitDisplayOrEnv) {
          if (looksMultiline) {
            tex = "\\begin{gather*}\n" + raw + "\n\\end{gather*}";
          } else {
            tex = "\\[" + raw + "\\]";
          }
        }

        if (!outputElement) return;
        outputElement.textContent = tex;

        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise([outputElement]).catch((err) =>
            console.error(err)
          );
        }
      }

      function insertAtCursor(textarea, text) {
        if (!textarea) return;
        const start = textarea.selectionStart != null ? textarea.selectionStart : textarea.value.length;
        const end   = textarea.selectionEnd != null ? textarea.selectionEnd : textarea.value.length;
        const value = textarea.value;

        textarea.value = value.slice(0, start) + text + value.slice(end);
        const newPos = start + text.length;

        textarea.focus();
        textarea.selectionStart = textarea.selectionEnd = newPos;
        textarea.dispatchEvent(new Event("input", { bubbles: true }));
      }

      // ---------- Notes textareas ----------
      const allTextareas = document.querySelectorAll(".latex-input");

      // ========================================================
      // Opens the popup based on the textarea cursor position
      // ========================================================
      function openPopupAtTextareaCursor(ta) {
        const rect = ta.getBoundingClientRect();
        const x = rect.left + window.scrollX + 40;
        const y = rect.top + window.scrollY + 20;

        const pos = ta.selectionStart != null ? ta.selectionStart : ta.value.length;
        const value = ta.value;

        let initialQuery = "";
        const lastBackslash = value.lastIndexOf("\\", pos - 1);
        if (lastBackslash !== -1 && lastBackslash < pos) {
          initialQuery = value.slice(lastBackslash + 1, pos);
        }

        if (window.showSymbolPopup) {
          window.showSymbolPopup({
            x,
            y,
            initialQuery,
            onSelect(symbol) {
              insertAtCursor(ta, symbol.latex);
            }
          });
        }
      }

      allTextareas.forEach((ta) => {
        // Live render on input
        ta.addEventListener("input", () => {
          const box = ta.closest(".group-notes");
          if (!box) return;
          const out = box.querySelector(".rendered-output");
          renderBlockTeX(ta, out);
        });

        let lastBackslashTime = 0;

        ta.addEventListener("keydown", (e) => {
          if (e.key === "\\") {
            const now = Date.now();

            // Rapid double press ‚Üí treat as shortcut
            if (now - lastBackslashTime < 250) {
              e.preventDefault(); // don't type this second "\"

              // üî• Remove the *previous* "\" that was just typed
              const pos = ta.selectionStart != null ? ta.selectionStart : ta.value.length;
              const value = ta.value;

              if (pos > 0 && value[pos - 1] === "\\") {
                ta.value = value.slice(0, pos - 1) + value.slice(pos);
                ta.selectionStart = ta.selectionEnd = pos - 1;
                // re-render after change
                ta.dispatchEvent(new Event("input", { bubbles: true }));
              }

              // Open the popup at the cursor
              openPopupAtTextareaCursor(ta);
              lastBackslashTime = 0; // reset
              return;
            }

            // First "\" ‚Üí let it type normally
            lastBackslashTime = now;
          }
        });

        // Optional: initial render
        const box = ta.closest(".group-notes");
        if (box) {
          const out = box.querySelector(".rendered-output");
          renderBlockTeX(ta, out);
        }
      });



      // ---------- Copy buttons ----------
      const noteGroups = document.querySelectorAll(".group-notes");
      noteGroups.forEach((group) => {
        const section  = group.closest(".problem-group");
        const textarea = group.querySelector(".latex-input");
        const button   = group.querySelector(".copy-btn");

        if (!button || !textarea || !section) return;

        button.addEventListener("click", async () => {
          const problems = Array.from(
            section.querySelectorAll(":scope > p")
          ).map((p) => p.textContent.trim());

          const problemBlock =
            "Problems:\n" +
            problems.map((t, i) => `${i + 1}. ${t}`).join("\n") +
            "\n\n";

          const latex = textarea.value.trim();
          const notesBlock = "Notes (LaTeX):\n" + latex + "\n";

          const combined = problemBlock + notesBlock;

          try {
            await navigator.clipboard.writeText(combined);
            button.classList.add("copied");
            setTimeout(() => button.classList.remove("copied"), 1200);
          } catch (err) {
            console.error("Clipboard error:", err);
            alert("Copy failed ‚Äì your browser may block clipboard access.");
          }
        });
      });

      // ---------- Drawing canvases ----------
      const canvases = document.querySelectorAll(".note-canvas");
      canvases.forEach((canvas) => {
        const ctx = canvas.getContext("2d");
        const clearBtn = canvas.closest(".canvas-block").querySelector(".clear-canvas");

        function resizeCanvas() {
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;

          canvas.width  = rect.width * dpr;
          canvas.height = rect.height * dpr;

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(dpr, dpr);

          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.lineWidth = 2;
        }

        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        let drawing = false;
        let lastX = 0;
        let lastY = 0;

        function getPos(evt) {
          const rect = canvas.getBoundingClientRect();
          if (evt.touches && evt.touches[0]) {
            return {
              x: evt.touches[0].clientX - rect.left,
              y: evt.touches[0].clientY - rect.top
            };
          } else {
            return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
          }
        }

        function startDraw(evt) {
          evt.preventDefault();
          drawing = true;
          const pos = getPos(evt);
          lastX = pos.x;
          lastY = pos.y;
        }

        function draw(evt) {
          if (!drawing) return;
          evt.preventDefault();
          const pos = getPos(evt);
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
          lastX = pos.x;
          lastY = pos.y;
        }

        function endDraw(evt) {
          if (!drawing) return;
          evt.preventDefault();
          drawing = false;
        }

        canvas.addEventListener("mousedown", startDraw);
        canvas.addEventListener("mousemove", draw);
        window.addEventListener("mouseup", endDraw);

        canvas.addEventListener("touchstart", startDraw, { passive: false });
        canvas.addEventListener("touchmove", draw, { passive: false });
        canvas.addEventListener("touchend", endDraw, { passive: false });
        canvas.addEventListener("touchcancel", endDraw, { passive: false });

        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
          });
        }
      });
    });
  </script>

</body>
</html>