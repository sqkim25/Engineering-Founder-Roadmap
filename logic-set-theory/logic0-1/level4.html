<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Logic 0 ‚Äì Level 4</title>

  <!-- Basic layout styles -->
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
                   sans-serif;
      line-height: 1.5;
      margin: 0;
      padding: 0;
      background: #f5f5f5;
    }

    header {
      background: #222;
      color: #fff;
      padding: 1rem 1.5rem;
    }

    header h1 {
      margin: 0;
      font-size: 1.6rem;
    }

    main {
      max-width: 900px;
      margin: 1.5rem auto 3rem;
      padding: 0 1rem 2rem;
      background: #fff;
      box-shadow: 0 0.5rem 1rem rgba(0,0,0,0.08);
      border-radius: 8px;
    }

    section {
      margin-bottom: 2rem;
    }

    h2 {
      margin-top: 1.5rem;
      margin-bottom: 0.5rem;
      font-size: 1.3rem;
    }

    h3 {
      margin-top: 1rem;
      margin-bottom: 0.4rem;
      font-size: 1.1rem;
    }

    .note {
      font-size: 0.9rem;
      color: #555;
      margin-bottom: 0.8rem;
    }

    .problem-group {
      border-top: 1px solid #eee;
      padding-top: 1.25rem;
      margin-top: 1.25rem;
    }

    .problem-group:first-of-type {
      border-top: none;
      padding-top: 0;
      margin-top: 0.5rem;
    }

    .latex-input {
      width: 100%;
      min-height: 70px;
      padding: 0.5rem;
      font-family: "Fira Code", "JetBrains Mono", Menlo, Monaco,
                   Consolas, "Courier New", monospace;
      font-size: 0.95rem;
      border-radius: 4px;
      border: 1px solid #ccc;
      box-sizing: border-box;
      resize: vertical;
      margin-bottom: 0.5rem;
    }

    .rendered-output {
      min-height: 2rem;
      padding: 0.5rem;
      border-radius: 4px;
      border: 1px dashed #ccc;
      background: #fafafa;
      margin-bottom: 0.5rem;
      text-align: center;
    }

    .rendered-output mjx-container {
      display: inline-block;
      margin-left: auto;
      margin-right: auto;
    }

    .controls {
      display: flex;
      justify-content: flex-end;
      gap: 0.5rem;
      margin-bottom: 0.3rem;
    }

    .copy-btn {
      padding: 0.3rem 0.7rem;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      background: #333;
      color: #fff;
      font-size: 0.9rem;
    }

    .copy-btn:active {
      transform: scale(0.97);
    }

    .copy-btn.copied::after {
      content: " ‚úì";
    }

    .canvas-wrapper {
      border: 1px solid #ccc;
      border-radius: 4px;
      overflow: hidden;
      background: #fff;
    }

    .canvas-block {
      margin-top: 0.75rem;
    }

    .note-canvas {
      display: block;
      width: 100%;
      height: 250px;
      touch-action: none; /* for better touch drawing */
    }

    .clear-canvas {
      margin-top: 0.4rem;
    }



  </style>

  <!-- MathJax for LaTeX rendering -->
  <script>
    window.MathJax = {
      tex: {
        packages: { "[+]": ["ams"] },
        inlineMath: [["\\(","\\)"], ["$","$"]],
        displayMath: [["\\[","\\]"], ["$$","$$"]]
      },
      svg: { fontCache: "global" }
    };
  </script>

  <script id="MathJax-script"
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
          async></script>
</head>
<body>
  <header>
    <h1>Logic 0 ‚Äì Level 4 Problems</h1>
  </header>

<main>
  <section>
    <p class="note">
      Level 4 (<strong>Analyze</strong>) problems ask you to <em>take structure apart</em>:
      compare forms, classify by properties, draw Hasse diagrams, contrast unions vs intersections, etc.
      After each group, use the LaTeX notes area and drawing pad to work things out.
    </p>
  </section>

  <!-- 1. Logical Form, Abbreviations, and Negation -->
  <section class="problem-group" id="group-1">
    <h2>1. Logical Form, Abbreviations, and Negation</h2>

    <p><strong>(L4.1)</strong>
      You are given four English patterns:
    </p>
    <ol>
      <li>‚ÄúIf \(P\), then \(Q\).‚Äù</li>
      <li>‚Äú\(P\) only if \(Q\).‚Äù</li>
      <li>‚Äú\(P\) if and only if \(Q\).‚Äù</li>
      <li>‚Äú\(Q\) if \(P\).‚Äù</li>
    </ol>
    <p><strong>(a)</strong> Group these into pairs that are <em>logically equivalent</em> after
      translation into symbols (using \(\Rightarrow,\Leftarrow,\Leftrightarrow\)).</p>
    <p><strong>(b)</strong> Explain which pair is ‚Äúone-way implication‚Äù and which expresses
      ‚Äútwo-way implication,‚Äù and where misunderstandings usually arise.</p>

    <p><strong>(L4.2)</strong>
      Consider the three statements about some fixed sets \(A,B\):
    </p>
    <ol>
      <li>\(\forall x(x\in A \Rightarrow x\in B)\)</li>
      <li>\(\forall x(x\in B \Rightarrow x\in A)\)</li>
      <li>\(\forall x(x\in A \Leftrightarrow x\in B)\)</li>
    </ol>
    <p><strong>(a)</strong> Draw the logical dependency graph: which combinations of (1) and (2)
      imply (3)? Does (3) imply (1) and (2)?</p>
    <p><strong>(b)</strong> Interpret each statement in plain English and explain how they relate to
      the concepts ‚Äúsubset‚Äù and ‚Äúequality of sets.‚Äù</p>

    <p><strong>(L4.3)</strong>
      For each statement, write its formal negation in symbols, then <strong>compare</strong> the
      negation to the original:
    </p>
    <ol>
      <li>\(\forall x(x\in A \Rightarrow x\in B)\)</li>
      <li>\(\forall x(x\in A \Leftrightarrow x\in B)\)</li>
    </ol>
    <p>
      Explain how the quantifier change and the ‚Äúslash on a symbol‚Äù encode the ‚Äúfailure mode‚Äù of
      each statement.
    </p>

    <!-- Notes + drawing for group 1 -->
    <div class="group-notes">
      <h3>Notes for Group 1</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ P \Rightarrow Q,\ P \Leftarrow Q,\ P \Leftrightarrow Q,\ \forall x(x\in A \Rightarrow x\in B),\ \exists x(x\in A \wedge x\notin B)"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Draw dependency graphs or Venn diagrams here.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 2. Sets and Extensionality -->
  <section class="problem-group" id="group-2">
    <h2>2. Sets and Extensionality</h2>

    <p><strong>(S4.1)</strong>
      You are given the following four descriptions:
    </p>
    <ul>
      <li>\(A = \{n\in \mathbb{Z} \mid n^2\le 4\}\)</li>
      <li>\(B = \{-2,-1,0,1,2\}\)</li>
      <li>\(C = \{x\in \mathbb{Z} \mid -2&lt;x&lt;2\}\)</li>
      <li>\(D = \{-1,0,1\}\)</li>
    </ul>
    <p><strong>(a)</strong> Partition \(\{A,B,C,D\}\) into groups of sets that are equal.</p>
    <p><strong>(b)</strong> For each equality you claim, explicitly analyze the membership condition:
      ‚Äúfor all \(t\), \(t\in X\Leftrightarrow t\in Y\)‚Äù.</p>
    <p><strong>(c)</strong> Identify which sets properly contain which others, and draw the Hasse
      diagram for the partial order \(\subseteq\) on \(\{A,B,C,D\}\).</p>

    <p><strong>(S4.2)</strong>
      Two students claim:
    </p>
    <ul>
      <li>Student 1: ‚ÄúThe description of a set doesn‚Äôt matter; only the elements matter.‚Äù</li>
      <li>Student 2: ‚ÄúDifferent descriptions always give different sets.‚Äù</li>
    </ul>
    <ol>
      <li>Construct one explicit example where <em>two different descriptions give the same set</em>.</li>
      <li>Construct one example where <em>two superficially similar descriptions give different
          sets</em> (e.g. a strict inequality vs. a non-strict one).</li>
      <li>Analyze which student is closer to the truth and why extensionality settles the dispute.</li>
    </ol>

    <!-- Notes + drawing for group 2 -->
    <div class="group-notes">
      <h3>Notes for Group 2</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ t\in A \Leftrightarrow t\in B,\ \{n\in\mathbb{Z} : n^2\le 4\},\ \text{Hasse diagram for } \{A,B,C,D\}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use this area for Hasse diagrams or membership tables.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 3. Adjoining Elements and Set-Building Structure -->
  <section class="problem-group" id="group-3">
    <h2>3. Adjoining Elements and Set-Building Structure</h2>

    <p><strong>(A4.1)</strong>
      Let \(A = \{0,2,4\}\), \(B = \{0,2,4,6\}\), and consider the operation
      \(A;t := A\cup\{t\}\).
    </p>
    <ol>
      <li>For each of \(t\in\{2,3,4,5,6\}\), compute \(A;t\).</li>
      <li>
        Partition the values of \(t\) into:
        <ul>
          <li>those with \(A;t = A\),</li>
          <li>those with \(A;t \neq A\).</li>
        </ul>
      </li>
      <li>
        Explain how the proposition ‚Äú\(t\in A \Leftrightarrow A;t=A\)‚Äù shows up
        <strong>structurally</strong> in your examples.
      </li>
    </ol>

    <p><strong>(A4.2)</strong>
      Suppose you repeatedly adjoin elements to the empty set:
    </p>
    <p>
      \[
        \varnothing; a_1; a_2; \dots; a_n
      \]
      (where the notation is left-associative, i.e.
      \(((\dots((\varnothing;a_1);a_2)\dots;a_n))\)).
    </p>
    <ol>
      <li>Analyze what set you obtain in terms of \(\{a_1,\dots,a_n\}\).</li>
      <li>Under what conditions on the \(a_i\)‚Äôs does the sequence of sets strictly increase at every step?</li>
      <li>Describe the precise sense in which ‚Äúadjoining‚Äù is a way to build <em>any finite set</em> starting from \(\varnothing\).</li>
    </ol>

    <!-- Notes + drawing for group 3 -->
    <div class="group-notes">
      <h3>Notes for Group 3</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ A;t = A\cup\{t\},\ t\in A \Leftrightarrow A;t=A,\ \varnothing;a_1;a_2;\dots;a_n"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Sketch chains of sets A ‚äÜ A;t ‚äÜ ‚Ä¶ here.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 4. Subsets, Power Sets, and Inclusion Structure -->
  <section class="problem-group" id="group-4">
    <h2>4. Subsets, Power Sets, and Inclusion Structure</h2>

    <p><strong>(P4.1)</strong>
      Let \(X = \{0,1,2\}\). Consider these four subsets:
    </p>
    <ul>
      <li>\(A = \{0\}\)</li>
      <li>\(B = \{0,1\}\)</li>
      <li>\(C = \{1,2\}\)</li>
      <li>\(D = X\)</li>
    </ul>
    <ol>
      <li>Draw the Hasse diagram of \((\mathcal{P}(X),\subseteq)\) and mark \(A,B,C,D\) on it.</li>
      <li>Analyze which of \(A,B,C,D\) are <em>comparable</em> by \(\subseteq\) and which are not.</li>
      <li>Explain how this diagram helps visualize the logical content of ‚Äú\(\subseteq\)‚Äù and why some pairs are incomparable.</li>
    </ol>

    <p><strong>(P4.2)</strong>
      Let \(E = \{a,b\}\) and \(F = \{a,b,c\}\).
    </p>
    <ol>
      <li>List \(\mathcal{P}(E)\) and \(\mathcal{P}(F)\).</li>
      <li>Determine whether \(\mathcal{P}(E)\subseteq \mathcal{P}(F)\).</li>
      <li>
        Analyze the general pattern: given \(A\subseteq B\), explain why
        \(\mathcal{P}(A)\subseteq \mathcal{P}(B)\) <strong>must</strong> hold by unpacking definitions
        (don‚Äôt just quote the fact‚Äîtrack the membership conditions).
      </li>
    </ol>

    <p><strong>(P4.3)</strong>
      You are given three sets:
    </p>
    <ul>
      <li>\(A = \{0,1\}\)</li>
      <li>\(B = \{\varnothing\}\)</li>
      <li>\(C = \{\varnothing,\{0\}\}\)</li>
    </ul>
    <p>
      For each pair \((X,Y)\) among \(\{A,B,C\}\), analyze:
    </p>
    <ol>
      <li>Is \(X\subseteq Y\)?</li>
      <li>Is \(X\in Y\)?</li>
    </ol>
    <p>
      Then summarize the main <em>pattern of confusion</em> that can arise when sets contain other
      sets vs. ordinary elements like numbers.
    </p>

    <!-- Notes + drawing for group 4 -->
    <div class="group-notes">
      <h3>Notes for Group 4</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ \mathcal{P}(X),\ \subseteq\ \text{vs}\ \in,\ \{\varnothing\},\ \{\varnothing,\{0\}\},\text{Hasse diagrams}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for subset lattices or inclusion diagrams.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 5. Unions, Intersections, and Families of Sets -->
  <section class="problem-group" id="group-5">
    <h2>5. Unions, Intersections, and Families of Sets</h2>

    <p><strong>(U4.1)</strong>
      For each \(n\in\mathbb{N}\), let \(A_n = \{n,n+1,n+2,\dots\}\subseteq \mathbb{N}\) (tails).
    </p>
    <ol>
      <li>Analyze whether the sequence \((A_n)\) is <em>increasing</em> or <em>decreasing</em> under \(\subseteq\).</li>
      <li>Determine \(\bigcup_{n\in\mathbb{N}} A_n\) and \(\bigcap_{n\in\mathbb{N}} A_n\).</li>
      <li>Explain how the behavior of the intersection captures the intuitive idea of ‚Äúwhat eventually belongs to every tail.‚Äù</li>
    </ol>

    <p><strong>(U4.2)</strong>
      Define, for each \(n\in\mathbb{N}\),
    </p>
    <p>
      \[
        B_n = \{0,1,2,\dots,n\}\subseteq \mathbb{N}\ \text{(initial segments)}.
      \]
    </p>
    <ol>
      <li>Analyze whether the sequence \((B_n)\) is increasing or decreasing.</li>
      <li>Determine \(\bigcup_{n\in\mathbb{N}} B_n\) and \(\bigcap_{n\in\mathbb{N}} B_n\).</li>
      <li>
        Compare the results with those for \((A_n)\) and explain how ‚Äútails‚Äù vs. ‚Äúinitial segments‚Äù
        produce opposite patterns for unions and intersections.
      </li>
    </ol>

    <p><strong>(U4.3)</strong>
      Let \(\mathcal{C} = \{\{0,1\},\{1,2\},\{2,3\}\}\).
    </p>
    <ol>
      <li>Compute \(\bigcup\mathcal{C}\) and \(\bigcap\mathcal{C}\).</li>
      <li>
        Now remove one set at a time (e.g. consider \(\{\{0,1\},\{1,2\}\}\), then
        \(\{\{1,2\},\{2,3\}\}\), etc.).
      </li>
      <li>
        Analyze how adding or removing a set from a family affects:
        <ul>
          <li>the union,</li>
          <li>the intersection.</li>
        </ul>
        Summarize the general pattern you observe.
      </li>
    </ol>

    <!-- Notes + drawing for group 5 -->
    <div class="group-notes">
      <h3>Notes for Group 5</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ A_n = \{n,n+1,\dots\},\ B_n = \{0,1,\dots,n\},\ \bigcup A_n,\ \bigcap A_n,\ \bigcup\mathcal{C},\ \bigcap\mathcal{C}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use this to visualize tails vs initial segments and family changes.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 6. Ordered Pairs, Tuples, and Segments -->
  <section class="problem-group" id="group-6">
    <h2>6. Ordered Pairs, Tuples, and Segments</h2>

    <p><strong>(OP4.1)</strong>
      Using Kuratowski‚Äôs definition \(\langle x,y\rangle = \{\{x\},\{x,y\}\}\), compare \(\langle x,y\rangle\) and \(\{x,y\}\).
    </p>
    <ol>
      <li>Show explicitly (with an example) that \(\langle x,y\rangle\) and \(\{x,y\}\) can have the same <em>underlying elements</em> when \(x=y\) but differ when \(x\neq y\).</li>
      <li>Analyze how Kuratowski‚Äôs construction ‚Äúforces in‚Äù the information about order using only sets.</li>
    </ol>

    <p><strong>(OP4.2)</strong>
      Let \(S = \langle a,b,c,d\rangle\).
    </p>
    <ol>
      <li>List all segments of \(S\).</li>
      <li>Group them into:
        <ul>
          <li>initial segments,</li>
          <li>non-initial segments.</li>
        </ul>
      </li>
      <li>
        For each group, describe the structural property that distinguishes it (without naming specific letters).
      </li>
    </ol>

    <p><strong>(OP4.3)</strong>
      Suppose we know that
    </p>
    <p>
      \[
        \langle x_1,x_2,\dots,x_m\rangle = \langle y_1,y_2,\dots,y_{m+k}\rangle
      \]
      and that we are in the setting of Lemma 0A (no element is itself a finite sequence).
    </p>
    <ol>
      <li>Analyze what this equality says about initial segments of the longer sequence.</li>
      <li>Explain why, under the corollary‚Äôs hypothesis, we must actually have \(k=0\) and \(x_i=y_i\) for all \(i\).</li>
      <li>Interpret this as a statement about the ‚Äúrigidity‚Äù of finite sequences.</li>
    </ol>

    <!-- Notes + drawing for group 6 -->
    <div class="group-notes">
      <h3>Notes for Group 6</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ \langle x,y\rangle = \{\{x\},\{x,y\}\},\ \text{segments of }\langle a,b,c,d\rangle,\ \text{Lemma 0A rigidity}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for drawing nested-pair structures and segment lattices.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 7. Cartesian Products and Relations -->
  <section class="problem-group" id="group-7">
    <h2>7. Cartesian Products and Relations</h2>

    <p><strong>(R4.1)</strong>
      Let \(A = \{0,1\}\) and \(B = \{a,b,c\}\).
    </p>
    <ol>
      <li>Describe structurally what every element of \(A\times B\) looks like, and every element of \(B\times A\).</li>
      <li>Compare \(|A\times B|\) and \(|B\times A|\).</li>
      <li>Analyze why these products have the same <em>size</em> but different <em>type</em> of objects, and how this reflects the role of order.</li>
    </ol>

    <p><strong>(R4.2)</strong>
      Consider the three relations on \(\{0,1,2\}\):
    </p>
    <ul>
      <li>\(R_1 = \{\langle 0,0\rangle,\langle 1,1\rangle,\langle 2,2\rangle\}\)</li>
      <li>\(R_2 = \{\langle 0,1\rangle,\langle 1,0\rangle\}\)</li>
      <li>\(R_3 = \{\langle 0,1\rangle,\langle 1,2\rangle,\langle 0,2\rangle\}\)</li>
    </ul>
    <ol>
      <li>For each relation, determine \(\operatorname{dom}(R_i)\), \(\operatorname{ran}(R_i)\), and \(\operatorname{fld}(R_i)\).</li>
      <li>Fill in a table indicating whether each is reflexive, symmetric, and/or transitive.</li>
      <li>
        Group the three relations into ‚Äúbehaviour types‚Äù based on these properties (e.g. ‚Äúidentity-like‚Äù, ‚Äúswap-like‚Äù, ‚Äúorder-like‚Äù), and explain the classification.
      </li>
    </ol>

    <p><strong>(R4.3)</strong>
      Let \((<)\) be the usual strict order on \(\{0,1,2,3\}\) viewed as a relation \(S\).
    </p>
    <ol>
      <li>Write \(S\) explicitly as a subset of \(\{0,1,2,3\}^2\).</li>
      <li>Analyze which of the four standard properties it has: reflexive, symmetric, transitive, trichotomy.</li>
      <li>For each property that fails, identify a minimal counterexample (a specific pair of elements that witnesses the failure).</li>
    </ol>

    <!-- Notes + drawing for group 7 -->
    <div class="group-notes">
      <h3>Notes for Group 7</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ A\times B,\ \operatorname{dom}R,\ \operatorname{ran}R,\ \operatorname{fld}R,\ \text{identity-like / swap-like / order-like}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for property tables and relation diagrams.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 8. Functions and Operations -->
  <section class="problem-group" id="group-8">
    <h2>8. Functions and Operations</h2>

    <p><strong>(F4.1)</strong>
      You are given three relations on \(\{0,1,2\}\):
    </p>
    <ul>
      <li>\(F_1 = \{\langle 0,1\rangle,\langle 1,1\rangle,\langle 2,1\rangle\}\)</li>
      <li>\(F_2 = \{\langle 0,1\rangle,\langle 0,2\rangle\}\)</li>
      <li>\(F_3 = \{\langle 0,0\rangle,\langle 1,1\rangle\}\)</li>
    </ul>
    <ol>
      <li>For each, decide whether it is a function (using the ‚Äúexactly one output per input‚Äù condition).</li>
      <li>Among those that are functions, analyze whether they are injective and/or surjective onto \(\{0,1,2\}\).</li>
      <li>Summarize which combinations of ‚Äúinjective/non-injective + surjective/non-surjective‚Äù actually occur in your examples.</li>
    </ol>

    <p><strong>(F4.2)</strong>
      Let \(f:\mathbb{Z}\to\mathbb{Z}\) be given by \(f(n)=2n\), and \(g:\mathbb{Z}\to\mathbb{Z}\) be given by \(g(n)=n^2\).
    </p>
    <ol>
      <li>Analyze and compare:
        <ul>
          <li>injectivity of \(f\) vs. \(g\),</li>
          <li>surjectivity of \(f\) vs. \(g\) onto \(\mathbb{Z}\).</li>
        </ul>
      </li>
      <li>
        Fill in a \(2\times 2\) table with rows = ‚Äúinjective / not injective‚Äù, columns = ‚Äúsurjective / not surjective‚Äù, and place \(f\) and \(g\) in the correct cells.
      </li>
      <li>
        Explain how the <em>algebraic form</em> of each function (\(2n\) vs. \(n^2\)) causes its specific injective/surjective behavior.
      </li>
    </ol>

    <p><strong>(F4.3)</strong>
      Let \(+\) be usual addition on \(\mathbb{Z}\). Consider these subsets:
    </p>
    <ul>
      <li>\(A = \mathbb{N}\)</li>
      <li>\(B = \{0,2,4,6,\dots\}\) (even naturals)</li>
      <li>\(C = \{0,1\}\)</li>
    </ul>
    <p>
      For each subset, analyze whether it is <em>closed</em> under \(+\) (viewed as a binary operation on \(\mathbb{Z}\)):
    </p>
    <ol>
      <li>If closed, describe the induced operation \(+\upharpoonright (X^2)\) on that subset.</li>
      <li>If not closed, exhibit a specific counterexample and explain why the restriction fails to be a binary operation on that subset.</li>
      <li>Summarize the structural difference between subsets that do and do not inherit an operation.</li>
    </ol>

    <!-- Notes + drawing for group 8 -->
    <div class="group-notes">
      <h3>Notes for Group 8</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ \text{function test},\ \text{injective/surjective table},\ f(n)=2n,\ g(n)=n^2,\ \text{closed under }+"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for mapping diagrams and closure examples.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 9. Standard Classes of Relations -->
  <section class="problem-group" id="group-9">
    <h2>9. Standard Classes of Relations</h2>

    <p><strong>(SR4.1)</strong>
      On \(A = \{1,2,3\}\), consider:
    </p>
    <ul>
      <li>\(R = \{\langle 1,1\rangle,\langle 2,2\rangle,\langle 3,3\rangle,\langle 1,2\rangle,\langle 2,1\rangle\}\)</li>
      <li>\(S = \{\langle 1,2\rangle,\langle 2,3\rangle,\langle 1,3\rangle\}\)</li>
    </ul>
    <ol>
      <li>Analyze whether \(R\) is an equivalence relation, an ordering relation, both, or neither. Justify by checking reflexive/symmetric/transitive/trichotomy.</li>
      <li>Do the same for \(S\).</li>
      <li>
        Classify each relation into: ‚Äúequivalence-like‚Äù, ‚Äúorder-like‚Äù, or ‚Äúneither‚Äù, and explain precisely which property (or properties) fail.
      </li>
    </ol>

    <p><strong>(SR4.2)</strong>
      On \(\mathbb{Z}\), define:
    </p>
    <ul>
      <li>\(a \sim b\) iff \(a-b\) is even.</li>
      <li>\(a \prec b\) iff \(a&lt;b\).</li>
    </ul>
    <ol>
      <li>For each relation, fill in a property table (reflexive? symmetric? transitive? trichotomy?).</li>
      <li>Analyze which is an equivalence relation and which is an ordering relation.</li>
      <li>Explain how the <em>shape</em> of equivalence classes for \(\sim\) differs from the <em>shape</em> of chains for \(\prec\).</li>
    </ol>

    <!-- Notes + drawing for group 9 -->
    <div class="group-notes">
      <h3>Notes for Group 9</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ \text{reflexive/symmetric/transitive/trichotomy tables},\ a\sim b,\ a\prec b,\ \text{equivalence vs order}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for property tables and visualizing classes vs chains.</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>

  <!-- 10. Equivalence Relations and Partitions -->
  <section class="problem-group" id="group-10">
    <h2>10. Equivalence Relations and Partitions</h2>

    <p><strong>(EQ4.1)</strong>
      On \(\mathbb{Z}\), define \(a \equiv_3 b\) iff \(3\mid (a-b)\).
    </p>
    <ol>
      <li>Describe the equivalence classes \([0]\), \([1]\), \([2]\).</li>
      <li>Show that every integer belongs to exactly one of these classes by analyzing the possible remainders modulo 3.</li>
      <li>
        Explain how these three classes collectively form a partition of \(\mathbb{Z}\) and why
        <strong>no other</strong> partition of \(\mathbb{Z}\) into three nonempty sets can define this same relation.
      </li>
    </ol>

    <p><strong>(EQ4.2)</strong>
      Suppose a relation \(R\) on a set \(A\) is reflexive and symmetric, but <em>not</em> transitive.
    </p>
    <ol>
      <li>Construct a concrete example on a small set (e.g. \(A=\{1,2,3\}\)) where transitivity fails.</li>
      <li>Analyze how the equivalence classes \([x]\) behave in your example: do they still form a partition?</li>
      <li>Explain why <strong>transitivity</strong> is exactly what guarantees that the sets \([x]\) are either disjoint or equal.</li>
    </ol>

    <p><strong>(EQ4.3)</strong>
      Let a relation \(\approx\) on \(\mathbb{R}\setminus\{0\}\) be defined by ‚Äú\(x\approx y\) iff \(\frac{x}{y}&gt;0\)‚Äù (same sign).
    </p>
    <ol>
      <li>Find the two equivalence classes explicitly.</li>
      <li>
        Consider the partition \(\{P,N\}\) of \(\mathbb{R}\setminus\{0\}\) into positive and negative numbers. Show that the equivalence relation induced by this partition is exactly \(\approx\).
      </li>
      <li>
        Analyze the general correspondence: given a partition of a set, how do you reconstruct the equivalence relation, and why do the equivalence classes coincide with the partition blocks?
      </li>
    </ol>

    <!-- Notes + drawing for group 10 -->
    <div class="group-notes">
      <h3>Notes for Group 10</h3>
      <div class="note">
        Type \\\\ quickly to open LaTeX snippet app on the note.
      </div>
      <textarea class="latex-input"
        placeholder="e.g.\ [x] = \{y\in A : \langle x,y\rangle\in R\},\ a\equiv_3 b,\ x\approx y \iff x/y&gt;0,\ \text{partition} \leftrightarrow \text{equivalence relation}"></textarea>
      <div class="rendered-output"></div>
      <div class="controls">
        <button class="copy-btn">Copy problems + notes</button>
      </div>
    </div>

    <div class="canvas-block">
      <div class="note">Use for partition pictures and class diagrams (mod 3, positive/negative).</div>
      <div class="canvas-wrapper">
        <canvas class="note-canvas"></canvas>
      </div>
      <button class="copy-btn clear-canvas">Clear drawing</button>
    </div>
  </section>
</main>


  <!-- Root for the React symbol popup -->
  <div id="symbol-popup-root"></div>

  <!-- React + ReactDOM + Babel (for JSX in this example) -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- React + JSX: ONLY the popup component + showSymbolPopup -->
  <script type="text/babel" data-presets="env,react">
    // ---------- Symbol data (you can expand this later) ----------
    window.SYMBOLS = [];
    window.RECENT_SYMBOLS = [];

    // ---------- Simple search ----------
    function searchSymbols(symbols, query) {
      const q = query.trim().toLowerCase();

      const recentList = Array.isArray(window.RECENT_SYMBOLS)
        ? window.RECENT_SYMBOLS
        : [];
      const recentSet = new Set(recentList);

      // ---------- Case 1: empty query ‚Üí show recent first ----------
      if (!q) {
        const seen = new Set();
        const recent = [];
        const others = [];

        // 1) Put recents first, in recency order
        for (const latex of recentList) {
          const sym = symbols.find((s) => s.latex === latex);
          if (sym && !seen.has(sym.latex)) {
            recent.push(sym);
            seen.add(sym.latex);
          }
        }

        // 2) Then all other symbols, sorted by priority
        for (const s of symbols) {
          if (!seen.has(s.latex)) {
            others.push(s);
          }
        }

        others.sort((a, b) => (b.priority || 0) - (a.priority || 0));

        return [...recent, ...others].slice(0, 20);
      }

      // ---------- Case 2: non-empty query ‚Üí scoring with recency boost ----------
      return symbols
        .map((s) => {
          const haystack = [
            s.label,
            s.latex,
            ...(s.keywords || []),
            ...(s.categories || [])
          ].join(" ").toLowerCase();

          if (!haystack.includes(q)) return null;

          let score = s.priority || 0;

          // Strong boost if this is a recent symbol
          const recIndex = recentList.indexOf(s.latex);
          if (recIndex !== -1) {
            const recencyWeight = 1.0 + (recentList.length - recIndex) * 0.05;
            score += recencyWeight;
          }

          if (s.latex.toLowerCase().startsWith("\\" + q)) score += 0.7;
          if ((s.keywords || []).some((k) => k.toLowerCase() === q)) score += 0.5;
          if (s.label.toLowerCase() === q) score += 0.4;

          const idx = haystack.indexOf(q);
          if (idx >= 0) score += Math.max(0, 0.3 - idx / 50);

          return { s, score };
        })
        .filter(Boolean)
        .sort((a, b) => b.score - a.score)
        .map((x) => x.s)
        .slice(0, 20);
    }


    // ---------- React popup component ----------
    const SymbolPopup = ({ x, y, initialQuery = "", onSelect, onClose }) => {
        const [query, setQuery] = React.useState("");
        const [highlightIndex, setHighlightIndex] = React.useState(0);
        const containerRef = React.useRef(null);
        const inputRef = React.useRef(null);

        const results = React.useMemo(
          () => searchSymbols(window.SYMBOLS || [], query),
          [query]
        );

        React.useEffect(() => {
          if (inputRef.current) {
            setTimeout(() => inputRef.current.focus(), 0);
          }
        }, []);

      React.useEffect(() => {
        if (inputRef.current) {
          setTimeout(() => inputRef.current.focus(), 0);
        }
      }, []);

      React.useEffect(() => {
        function handleClickOutside(e) {
          if (!containerRef.current) return;
          if (!containerRef.current.contains(e.target)) {
            onClose();
          }
        }
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
      }, [onClose]);

      const handleKeyDown = (e) => {
        const count = results.length;
        if (e.key === "ArrowDown") {
          e.preventDefault();
          if (count === 0) return;
          setHighlightIndex((prev) => (prev + 1) % count);
        } else if (e.key === "ArrowUp") {
          e.preventDefault();
          if (count === 0) return;
          setHighlightIndex((prev) => (prev - 1 + count) % count);
        } else if (e.key === "Enter") {
          e.preventDefault();
          if (count === 0) return;
          onSelect(results[highlightIndex]);
        } else if (e.key === "Escape") {
          e.preventDefault();
          onClose();
        }
      };

      return (
        <div
          ref={containerRef}
          style={{
            position: "absolute",
            left: x,
            top: y,
            zIndex: 9999,
            minWidth: 260,
            maxWidth: 360,
            background: "#fff",
            border: "1px solid #ddd",
            borderRadius: 6,
            boxShadow: "0 8px 24px rgba(0,0,0,0.12)",
            padding: 8,
            fontFamily:
              'system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif',
            fontSize: 13
          }}
        >
          <input
            ref={inputRef}
            value={query}
            onChange={(e) => {
              setQuery(e.target.value);
              setHighlightIndex(0);
            }}
            onKeyDown={handleKeyDown}
            placeholder="Search symbol or LaTeX‚Ä¶"
            style={{
              width: "100%",
              boxSizing: "border-box",
              padding: "4px 6px",
              marginBottom: 6,
              borderRadius: 4,
              border: "1px solid #ccc",
              outline: "none"
            }}
          />

          <div style={{ maxHeight: 260, overflowY: "auto" }}>
            {results.map((sym, idx) => (
              <div
                key={sym.latex + idx}
                style={{
                  display: "flex",
                  alignItems: "center",
                  padding: "4px 6px",
                  borderRadius: 4,
                  background: idx === highlightIndex ? "#eef3ff" : "transparent",
                  cursor: "pointer"
                }}
                onMouseDown={(e) => {
                  e.preventDefault();
                  onSelect(sym);
                }}
              >
                <span
                  style={{
                    width: 32,
                    textAlign: "center",
                    fontSize: 18,
                    marginRight: 6
                  }}
                >
                  {sym.label}
                </span>
                <div
                  style={{
                    display: "flex",
                    flexDirection: "column",
                    flex: 1,
                    overflow: "hidden"
                  }}
                >
                  <span
                    style={{
                      fontFamily: "monospace",
                      fontSize: 12,
                      whiteSpace: "nowrap",
                      overflow: "hidden",
                      textOverflow: "ellipsis"
                    }}
                  >
                    {sym.latex}
                  </span>
                  {sym.keywords && sym.keywords.length > 0 && (
                    <span
                      style={{
                        fontSize: 11,
                        color: "#777",
                        whiteSpace: "nowrap",
                        overflow: "hidden",
                        textOverflow: "ellipsis"
                      }}
                    >
                      {sym.keywords.slice(0, 4).join(", ")}
                    </span>
                  )}
                </div>
              </div>
            ))}

            {results.length === 0 && (
              <div
                style={{
                  padding: "4px 6px",
                  fontSize: 12,
                  color: "#888"
                }}
              >
                No matches
              </div>
            )}
          </div>
        </div>
      );
    };

    // ---------- Helper: show popup from vanilla JS ----------
    const popupRoot = ReactDOM.createRoot(
      document.getElementById("symbol-popup-root")
    );

    window.showSymbolPopup = function ({ x, y, initialQuery, onSelect }) {
      const handleSelect = (symbol) => {
        // --- Update recent list (per session, in-memory) ---
        if (!Array.isArray(window.RECENT_SYMBOLS)) {
          window.RECENT_SYMBOLS = [];
        }
        const arr = window.RECENT_SYMBOLS;
        const latex = symbol.latex;

        // Remove if already present
        const existingIndex = arr.indexOf(latex);
        if (existingIndex !== -1) {
          arr.splice(existingIndex, 1);
        }
        // Add to front
        arr.unshift(latex);
        // Keep list bounded (e.g. last 30 unique symbols)
        if (arr.length > 30) {
          arr.length = 30;
        }

        // Pass selection back to caller (inserts in textarea, etc.)
        onSelect(symbol);

        // Close popup
        popupRoot.render(null);
      };

      const handleClose = () => {
        popupRoot.render(null);
      };

      popupRoot.render(
        <SymbolPopup
          x={x}
          y={y}
          initialQuery={initialQuery}
          onSelect={handleSelect}
          onClose={handleClose}
        />
      );
    };

  </script>

  <!-- Plain JS: MathJax rendering, copy, canvas, backslash trigger -->
  <script>
    document.addEventListener("DOMContentLoaded", function () {
      // Load symbols.json
      fetch("../../symbols.json")
        .then((res) => res.json())
        .then((data) => {
          window.SYMBOLS = Array.isArray(data) ? data : (data.symbols || []);
          console.log("Loaded symbols:", window.SYMBOLS.length);
        })
        .catch((err) => {
          console.error("Failed to load symbols.json", err);
          window.SYMBOLS = [];
        });

      function renderBlockTeX(textarea, outputElement) {
        const raw = textarea.value.trim();
        if (!raw) {
          if (outputElement) outputElement.innerHTML = "";
          return;
        }

        let tex = raw;
        const explicitDisplayOrEnv = /^(\$\$|\\\[|\\begin\{)/.test(raw);
        const looksMultiline = raw.includes("\\\\") || raw.includes("\n");

        if (!explicitDisplayOrEnv) {
          if (looksMultiline) {
            tex = "\\begin{gather*}\n" + raw + "\n\\end{gather*}";
          } else {
            tex = "\\[" + raw + "\\]";
          }
        }

        if (!outputElement) return;
        outputElement.textContent = tex;

        if (window.MathJax && MathJax.typesetPromise) {
          MathJax.typesetPromise([outputElement]).catch((err) =>
            console.error(err)
          );
        }
      }

      function insertAtCursor(textarea, text) {
        if (!textarea) return;
        const start = textarea.selectionStart != null ? textarea.selectionStart : textarea.value.length;
        const end   = textarea.selectionEnd != null ? textarea.selectionEnd : textarea.value.length;
        const value = textarea.value;

        textarea.value = value.slice(0, start) + text + value.slice(end);
        const newPos = start + text.length;

        textarea.focus();
        textarea.selectionStart = textarea.selectionEnd = newPos;
        textarea.dispatchEvent(new Event("input", { bubbles: true }));
      }

      // ---------- Notes textareas ----------
      const allTextareas = document.querySelectorAll(".latex-input");

      // ========================================================
      // Opens the popup based on the textarea cursor position
      // ========================================================
      function openPopupAtTextareaCursor(ta) {
        const rect = ta.getBoundingClientRect();
        const x = rect.left + window.scrollX + 40;
        const y = rect.top + window.scrollY + 20;

        const pos = ta.selectionStart != null ? ta.selectionStart : ta.value.length;
        const value = ta.value;

        let initialQuery = "";
        const lastBackslash = value.lastIndexOf("\\", pos - 1);
        if (lastBackslash !== -1 && lastBackslash < pos) {
          initialQuery = value.slice(lastBackslash + 1, pos);
        }

        if (window.showSymbolPopup) {
          window.showSymbolPopup({
            x,
            y,
            initialQuery,
            onSelect(symbol) {
              insertAtCursor(ta, symbol.latex);
            }
          });
        }
      }

      allTextareas.forEach((ta) => {
        // Live render on input
        ta.addEventListener("input", () => {
          const box = ta.closest(".group-notes");
          if (!box) return;
          const out = box.querySelector(".rendered-output");
          renderBlockTeX(ta, out);
        });

        let lastBackslashTime = 0;

        ta.addEventListener("keydown", (e) => {
          if (e.key === "\\") {
            const now = Date.now();

            // Rapid double press ‚Üí treat as shortcut
            if (now - lastBackslashTime < 250) {
              e.preventDefault(); // don't type this second "\"

              // üî• Remove the *previous* "\" that was just typed
              const pos = ta.selectionStart != null ? ta.selectionStart : ta.value.length;
              const value = ta.value;

              if (pos > 0 && value[pos - 1] === "\\") {
                ta.value = value.slice(0, pos - 1) + value.slice(pos);
                ta.selectionStart = ta.selectionEnd = pos - 1;
                // re-render after change
                ta.dispatchEvent(new Event("input", { bubbles: true }));
              }

              // Open the popup at the cursor
              openPopupAtTextareaCursor(ta);
              lastBackslashTime = 0; // reset
              return;
            }

            // First "\" ‚Üí let it type normally
            lastBackslashTime = now;
          }
        });

        // Optional: initial render
        const box = ta.closest(".group-notes");
        if (box) {
          const out = box.querySelector(".rendered-output");
          renderBlockTeX(ta, out);
        }
      });



      // ---------- Copy buttons ----------
      const noteGroups = document.querySelectorAll(".group-notes");
      noteGroups.forEach((group) => {
        const section  = group.closest(".problem-group");
        const textarea = group.querySelector(".latex-input");
        const button   = group.querySelector(".copy-btn");

        if (!button || !textarea || !section) return;

        button.addEventListener("click", async () => {
          const problems = Array.from(
            section.querySelectorAll(":scope > p")
          ).map((p) => p.textContent.trim());

          const problemBlock =
            "Problems:\n" +
            problems.map((t, i) => `${i + 1}. ${t}`).join("\n") +
            "\n\n";

          const latex = textarea.value.trim();
          const notesBlock = "Notes (LaTeX):\n" + latex + "\n";

          const combined = problemBlock + notesBlock;

          try {
            await navigator.clipboard.writeText(combined);
            button.classList.add("copied");
            setTimeout(() => button.classList.remove("copied"), 1200);
          } catch (err) {
            console.error("Clipboard error:", err);
            alert("Copy failed ‚Äì your browser may block clipboard access.");
          }
        });
      });

      // ---------- Drawing canvases ----------
      const canvases = document.querySelectorAll(".note-canvas");
      canvases.forEach((canvas) => {
        const ctx = canvas.getContext("2d");
        const clearBtn = canvas.closest(".canvas-block").querySelector(".clear-canvas");

        function resizeCanvas() {
          const rect = canvas.getBoundingClientRect();
          const dpr = window.devicePixelRatio || 1;

          canvas.width  = rect.width * dpr;
          canvas.height = rect.height * dpr;

          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.scale(dpr, dpr);

          ctx.lineCap = "round";
          ctx.lineJoin = "round";
          ctx.lineWidth = 2;
        }

        resizeCanvas();
        window.addEventListener("resize", resizeCanvas);

        let drawing = false;
        let lastX = 0;
        let lastY = 0;

        function getPos(evt) {
          const rect = canvas.getBoundingClientRect();
          if (evt.touches && evt.touches[0]) {
            return {
              x: evt.touches[0].clientX - rect.left,
              y: evt.touches[0].clientY - rect.top
            };
          } else {
            return {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
          }
        }

        function startDraw(evt) {
          evt.preventDefault();
          drawing = true;
          const pos = getPos(evt);
          lastX = pos.x;
          lastY = pos.y;
        }

        function draw(evt) {
          if (!drawing) return;
          evt.preventDefault();
          const pos = getPos(evt);
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
          lastX = pos.x;
          lastY = pos.y;
        }

        function endDraw(evt) {
          if (!drawing) return;
          evt.preventDefault();
          drawing = false;
        }

        canvas.addEventListener("mousedown", startDraw);
        canvas.addEventListener("mousemove", draw);
        window.addEventListener("mouseup", endDraw);

        canvas.addEventListener("touchstart", startDraw, { passive: false });
        canvas.addEventListener("touchmove", draw, { passive: false });
        canvas.addEventListener("touchend", endDraw, { passive: false });
        canvas.addEventListener("touchcancel", endDraw, { passive: false });

        if (clearBtn) {
          clearBtn.addEventListener("click", () => {
            const rect = canvas.getBoundingClientRect();
            ctx.clearRect(0, 0, rect.width, rect.height);
          });
        }
      });
    });
  </script>

</body>
</html>